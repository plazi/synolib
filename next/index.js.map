{
  "version": 3,
  "sources": ["../SparqlEndpoint.ts", "../SynonymGroup.ts", "index.ts"],
  "sourcesContent": ["async function sleep(ms: number): Promise<void> {\n  const p = new Promise<void>((resolve) => {\n    setTimeout(resolve, ms);\n  });\n  return await p;\n}\n\n/** Describes the format of the JSON return by SPARQL endpoints */\nexport type SparqlJson = {\n  head: {\n    vars: string[];\n  };\n  results: {\n    bindings: {\n      [key: string]:\n        | { type: string; value: string; \"xml:lang\"?: string }\n        | undefined;\n    }[];\n  };\n};\n\n/**\n * Represents a remote sparql endpoint and provides a uniform way to run queries.\n */\nexport class SparqlEndpoint {\n  /** Create a new SparqlEndpoint with the given URI */\n  constructor(private sparqlEnpointUri: string) {}\n\n  /** @ignore */\n  // reasons: string[] = [];\n\n  /**\n   * Run a query against the sparql endpoint\n   *\n   * It automatically retries up to 10 times on fetch errors, waiting 50ms on the first retry and doupling the wait each time.\n   * Retries are logged to the console (`console.warn`)\n   *\n   * @throws In case of non-ok response status codes or if fetch failed 10 times.\n   * @param query The sparql query to run against the endpoint\n   * @param fetchOptions Additional options for the `fetch` request\n   * @param _reason (Currently ignored, used internally for debugging purposes)\n   * @returns Results of the query\n   */\n  async getSparqlResultSet(\n    query: string,\n    fetchOptions: RequestInit = {},\n    _reason = \"\",\n  ): Promise<SparqlJson> {\n    // this.reasons.push(_reason);\n\n    fetchOptions.headers = fetchOptions.headers || {};\n    (fetchOptions.headers as Record<string, string>)[\"Accept\"] =\n      \"application/sparql-results+json\";\n    let retryCount = 0;\n    const sendRequest = async (): Promise<SparqlJson> => {\n      try {\n        // console.info(`SPARQL ${_reason} (${retryCount + 1})`);\n        const response = await fetch(\n          this.sparqlEnpointUri + \"?query=\" + encodeURIComponent(query),\n          fetchOptions,\n        );\n        if (!response.ok) {\n          throw new Error(\"Response not ok. Status \" + response.status);\n        }\n        return await response.json();\n      } catch (error) {\n        if (fetchOptions.signal?.aborted) {\n          throw error;\n        } else if (retryCount < 10) {\n          const wait = 50 * (1 << retryCount++);\n          console.warn(`!! Fetch Error. Retrying in ${wait}ms (${retryCount})`);\n          await sleep(wait);\n          return await sendRequest();\n        }\n        console.warn(\"!! Fetch Error:\", query, \"\\n---\\n\", error);\n        throw error;\n      }\n    };\n    return await sendRequest();\n  }\n}\n", "import { SparqlEndpoint, SparqlJson } from \"./mod.ts\";\n\n/** Finds all synonyms of a taxon */\nexport class SynonymGroup implements AsyncIterable<Name> {\n  /** Indicates whether the SynonymGroup has found all synonyms.\n   *\n   * @readonly\n   */\n  isFinished = false;\n  /** Used internally to watch for new names found */\n  private monitor = new EventTarget();\n\n  /** Used internally to abort in-flight network requests when SynonymGroup is aborted */\n  private controller = new AbortController();\n\n  /** The SparqlEndpoint used */\n  private sparqlEndpoint: SparqlEndpoint;\n\n  /**\n   * List of names found so-far.\n   *\n   * Contains full list of synonyms _if_ .isFinished and not .isAborted\n   *\n   * @readonly\n   */\n  names: Name[] = [];\n  /**\n   * Add a new Name to this.names.\n   *\n   * Note: does not deduplicate on its own\n   *\n   * @internal */\n  private pushName(name: Name) {\n    this.names.push(name);\n    this.monitor.dispatchEvent(new CustomEvent(\"updated\"));\n  }\n\n  /**\n   * Call when all synonyms are found\n   *\n   * @internal */\n  private finish() {\n    this.isFinished = true;\n    this.monitor.dispatchEvent(new CustomEvent(\"updated\"));\n  }\n\n  /** contains TN, TC, CoL uris of synonyms which are in-flight somehow or are done already */\n  private expanded = new Set<string>(); // new Map<string, NameStatus>();\n\n  /** contains CoL uris where we don't need to check for Col \"acceptedName\" links\n   *\n   * col -> accepted col\n   */\n  private acceptedCol = new Map<string, string>();\n\n  /**\n   * Used internally to deduplicate treatments, maps from URI to Object.\n   *\n   * Contains full list of treatments _if_ .isFinished and not .isAborted\n   *\n   * @readonly\n   */\n  treatments = new Map<string, Treatment>();\n\n  /**\n   * Whether to show taxa deprecated by CoL that would not have been found otherwise.\n   * This significantly increases the number of results in some cases.\n   */\n  ignoreDeprecatedCoL: boolean;\n\n  /**\n   * if set to true, subTaxa of the search term are also considered as starting points.\n   *\n   * Not that \"weird\" ranks like subGenus are always included when searching for a genus by latin name.\n   */\n  startWithSubTaxa: boolean;\n\n  /**\n   * Constructs a SynonymGroup\n   *\n   * @param sparqlEndpoint SPARQL-Endpoint to query\n   * @param taxonName either a string of the form \"Genus species infraspecific\" (species & infraspecific names optional), or an URI of a http://filteredpush.org/ontologies/oa/dwcFP#TaxonConcept or ...#TaxonName or a CoL taxon URI\n   * @param [ignoreDeprecatedCoL=true] Whether to show taxa deprecated by CoL that would not have been found otherwise\n   * @param [startWithSubTaxa=false] if set to true, subTaxa of the search term are also considered as starting points.\n   */\n  constructor(\n    sparqlEndpoint: SparqlEndpoint,\n    taxonName: string,\n    ignoreDeprecatedCoL = true,\n    startWithSubTaxa = false,\n  ) {\n    this.sparqlEndpoint = sparqlEndpoint;\n    this.ignoreDeprecatedCoL = ignoreDeprecatedCoL;\n    this.startWithSubTaxa = startWithSubTaxa;\n\n    if (taxonName.startsWith(\"http\")) {\n      this.getName(taxonName, { searchTerm: true, subTaxon: false }).finally(\n        () => this.finish(),\n      );\n    } else {\n      const name = [\n        ...taxonName.split(\" \").filter((n) => !!n),\n        undefined,\n        undefined,\n      ] as [string, string | undefined, string | undefined];\n      this.getNameFromLatin(name, { searchTerm: true, subTaxon: false })\n        .finally(\n          () => this.finish(),\n        );\n    }\n  }\n\n  /** @internal */\n  private async getName(\n    taxonName: string,\n    justification: Justification,\n  ): Promise<void> {\n    if (this.expanded.has(taxonName)) {\n      console.log(\"Skipping known\", taxonName);\n      return;\n    }\n\n    if (taxonName.startsWith(\"https://www.catalogueoflife.org\")) {\n      await this.getNameFromCol(taxonName, justification);\n    } else if (taxonName.startsWith(\"http://taxon-concept.plazi.org\")) {\n      await this.getNameFromTC(taxonName, justification);\n    } else if (taxonName.startsWith(\"http://taxon-name.plazi.org\")) {\n      await this.getNameFromTN(taxonName, justification);\n    } else {\n      throw `Cannot handle name-uri <${taxonName}> !`;\n    }\n\n    if (\n      this.startWithSubTaxa && justification.searchTerm &&\n      !justification.subTaxon\n    ) {\n      await this.getSubtaxa(taxonName);\n    }\n  }\n\n  /** @internal */\n  private async getSubtaxa(url: string): Promise<void> {\n    const query = url.startsWith(\"http://taxon-concept.plazi.org\")\n      ? `\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT ?sub WHERE {\n  BIND(<${url}> as ?url)\n  ?sub trt:hasParentName*/^trt:hasTaxonName ?url .\n}\nLIMIT 5000`\n      : `\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT ?sub WHERE {\n  BIND(<${url}> as ?url)\n  ?sub (dwc:parent|trt:hasParentName)* ?url .\n}\nLIMIT 5000`;\n\n    if (this.controller.signal?.aborted) return Promise.reject();\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `Subtaxa ${url}`,\n    );\n\n    const names = json.results.bindings\n      .map((n) => n.sub?.value)\n      .filter((n) => n && !this.expanded.has(n)) as string[];\n\n    await Promise.allSettled(\n      names.map((n) => this.getName(n, { searchTerm: true, subTaxon: true })),\n    );\n  }\n\n  /** @internal */\n  private async getNameFromLatin(\n    [genus, species, infrasp]: [string, string | undefined, string | undefined],\n    justification: Justification,\n  ): Promise<void> {\n    const query = `\n    PREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nSELECT DISTINCT ?uri WHERE {\n  ?uri dwc:genus|dwc:genericName \"${genus}\" .\n  ${\n      species\n        ? `?uri dwc:species|dwc:specificEpithet \"${species}\" .`\n        : \"FILTER NOT EXISTS { ?uri dwc:species|dwc:specificEpithet ?species . }\"\n    }\n  ${\n      infrasp\n        ? `?uri dwc:subspecies|dwc:variety|dwc:infraspecificEpithet \"${infrasp}\" .`\n        : \"FILTER NOT EXISTS { ?uri dwc:subspecies|dwc:variety|dwc:infraspecificEpithet ?infrasp . }\"\n    }\n}\nLIMIT 500`;\n\n    if (this.controller.signal?.aborted) return Promise.reject();\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `NameFromLatin ${genus} ${species} ${infrasp}`,\n    );\n\n    const names = json.results.bindings\n      .map((n) => n.uri?.value)\n      .filter((n) => n && !this.expanded.has(n)) as string[];\n\n    await Promise.allSettled(names.map((n) => this.getName(n, justification)));\n  }\n\n  /** @internal */\n  private async getNameFromCol(\n    colUri: string,\n    justification: Justification,\n  ): Promise<void> {\n    // Note: this query assumes that there is no sub-species taxa with missing dwc:species\n    // Note: the handling assumes that at most one taxon-name matches this colTaxon\n    const query = `\nPREFIX dc: <http://purl.org/dc/elements/1.1/>\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nPREFIX dwcFP: <http://filteredpush.org/ontologies/oa/dwcFP#>\nPREFIX cito: <http://purl.org/spar/cito/>\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\n  (group_concat(DISTINCT ?tcauth;separator=\" / \") AS ?tcAuth)\n  (group_concat(DISTINCT ?aug;separator=\"|\") as ?augs)\n  (group_concat(DISTINCT ?def;separator=\"|\") as ?defs)\n  (group_concat(DISTINCT ?dpr;separator=\"|\") as ?dprs)\n  (group_concat(DISTINCT ?cite;separator=\"|\") as ?cites)\n  (group_concat(DISTINCT ?trtn;separator=\"|\") as ?tntreats)\n  (group_concat(DISTINCT ?citetn;separator=\"|\") as ?tncites) WHERE {\n  BIND(<${colUri}> as ?col)\n  ?col dwc:taxonRank ?rank .\n  OPTIONAL { ?col dwc:scientificNameAuthorship ?colAuth . } BIND(COALESCE(?colAuth, \"\") as ?authority)\n  ?col dwc:scientificName ?name . # Note: contains authority\n  ?col dwc:genericName ?genus .\n  # TODO # ?col dwc:parent* ?p . ?p dwc:rank \"kingdom\" ; dwc:taxonName ?kingdom .\n  OPTIONAL {\n    ?col dwc:specificEpithet ?species .\n    OPTIONAL { ?col dwc:infraspecificEpithet ?infrasp . }\n  }\n\n  OPTIONAL {\n    ?tn a dwcFP:TaxonName .\n    ?tn dwc:rank ?rank .\n    ?tn dwc:genus ?genus .\n    ?tn dwc:kingdom ?kingdom .\n    {\n      ?col dwc:specificEpithet ?species .\n      ?tn dwc:species ?species .\n      {\n        ?col dwc:infraspecificEpithet ?infrasp .\n        ?tn dwc:subspecies|dwc:variety ?infrasp .\n      } UNION {\n        FILTER NOT EXISTS { ?col dwc:infraspecificEpithet ?infrasp . }\n        FILTER NOT EXISTS { ?tn dwc:subspecies|dwc:variety ?infrasp . }\n      }\n    } UNION {\n      FILTER NOT EXISTS { ?col dwc:specificEpithet ?species . }\n      FILTER NOT EXISTS { ?tn dwc:species ?species . }\n    }\n\n    OPTIONAL {\n      ?trtnt trt:treatsTaxonName ?tn .\n      OPTIONAL { ?trtnt trt:publishedIn/dc:date ?trtndate . }\n      BIND(CONCAT(STR(?trtnt), \">\", COALESCE(?trtndate, \"\")) AS ?trtn)\n    }\n    OPTIONAL {\n      ?citetnt trt:citesTaxonName ?tn .\n      OPTIONAL { ?citetnt trt:publishedIn/dc:date ?citetndate . }\n      BIND(CONCAT(STR(?citetnt), \">\", COALESCE(?citetndate, \"\")) AS ?citetn)\n    }\n\n    OPTIONAL {\n      ?tc trt:hasTaxonName ?tn ;\n          dwc:scientificNameAuthorship ?tcauth ;\n          a dwcFP:TaxonConcept .\n      OPTIONAL {\n        ?augt trt:augmentsTaxonConcept ?tc .\n        OPTIONAL { ?augt trt:publishedIn/dc:date ?augdate . }\n        BIND(CONCAT(STR(?augt), \">\", COALESCE(?augdate, \"\")) AS ?aug)\n      }\n      OPTIONAL {\n        ?deft trt:definesTaxonConcept ?tc .\n        OPTIONAL { ?deft trt:publishedIn/dc:date ?defdate . }\n        BIND(CONCAT(STR(?deft), \">\", COALESCE(?defdate, \"\")) AS ?def)\n      }\n      OPTIONAL {\n        ?dprt trt:deprecates ?tc .\n        OPTIONAL { ?dprt trt:publishedIn/dc:date ?dprdate . }\n            BIND(CONCAT(STR(?dprt), \">\", COALESCE(?dprdate, \"\")) AS ?dpr)\n      }\n      OPTIONAL {\n        ?citet cito:cites ?tc . \n        OPTIONAL { ?citet trt:publishedIn/dc:date ?citedate . }\n            BIND(CONCAT(STR(?citet), \">\", COALESCE(?citedate, \"\")) AS ?cite)\n      }\n    }\n  }\n}\nGROUP BY ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\nLIMIT 500`;\n    // For unclear reasons, the query breaks if the limit is removed.\n\n    if (this.controller.signal?.aborted) return Promise.reject();\n\n    /// ?tn ?tc !rank !genus ?species ?infrasp !name !authority ?tcAuth\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `NameFromCol ${colUri}`,\n    );\n\n    return this.handleName(json, justification);\n  }\n\n  /** @internal */\n  private async getNameFromTC(\n    tcUri: string,\n    justification: Justification,\n  ): Promise<void> {\n    // Note: this query assumes that there is no sub-species taxa with missing dwc:species\n    // Note: the handling assumes that at most one taxon-name matches this colTaxon\n    const query = `\nPREFIX dc: <http://purl.org/dc/elements/1.1/>\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nPREFIX dwcFP: <http://filteredpush.org/ontologies/oa/dwcFP#>\nPREFIX cito: <http://purl.org/spar/cito/>\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\n  (group_concat(DISTINCT ?tcauth;separator=\" / \") AS ?tcAuth)\n  (group_concat(DISTINCT ?aug;separator=\"|\") as ?augs)\n  (group_concat(DISTINCT ?def;separator=\"|\") as ?defs)\n  (group_concat(DISTINCT ?dpr;separator=\"|\") as ?dprs)\n  (group_concat(DISTINCT ?cite;separator=\"|\") as ?cites)\n  (group_concat(DISTINCT ?trtn;separator=\"|\") as ?tntreats)\n  (group_concat(DISTINCT ?citetn;separator=\"|\") as ?tncites) WHERE {\n  <${tcUri}> trt:hasTaxonName ?tn .\n  ?tc trt:hasTaxonName ?tn ;\n      dwc:scientificNameAuthorship ?tcauth ;\n      a dwcFP:TaxonConcept .\n\n  ?tn a dwcFP:TaxonName .\n  ?tn dwc:rank ?rank .\n  ?tn dwc:kingdom ?kingdom .\n  ?tn dwc:genus ?genus .\n  OPTIONAL {\n    ?tn dwc:species ?species .\n    OPTIONAL { ?tn dwc:subspecies|dwc:variety ?infrasp . }\n  }\n  \n  OPTIONAL {\n    ?col dwc:taxonRank ?rank .\n    OPTIONAL { ?col dwc:scientificNameAuthorship ?colAuth . }\n    ?col dwc:scientificName ?fullName . # Note: contains authority\n    ?col dwc:genericName ?genus .\n    # TODO # ?col dwc:parent* ?p . ?p dwc:rank \"kingdom\" ; dwc:taxonName ?kingdom .\n\n    {\n      ?col dwc:specificEpithet ?species .\n      ?tn dwc:species ?species .\n      {\n        ?col dwc:infraspecificEpithet ?infrasp .\n        ?tn dwc:subspecies|dwc:variety ?infrasp .\n      } UNION {\n        FILTER NOT EXISTS { ?col dwc:infraspecificEpithet ?infrasp . }\n        FILTER NOT EXISTS { ?tn dwc:subspecies|dwc:variety ?infrasp . }\n      }\n    } UNION {\n      FILTER NOT EXISTS { ?col dwc:specificEpithet ?species . }\n      FILTER NOT EXISTS { ?tn dwc:species ?species . }\n    }\n  }\n  \n  BIND(COALESCE(?fullName, CONCAT(?genus, COALESCE(CONCAT(\" (\",?subgenus,\")\"), \"\"), COALESCE(CONCAT(\" \",?species), \"\"), COALESCE(CONCAT(\" \", ?infrasp), \"\"))) as ?name)\n  BIND(COALESCE(?colAuth, \"\") as ?authority)\n\n  OPTIONAL {\n    ?trtnt trt:treatsTaxonName ?tn .\n    OPTIONAL { ?trtnt trt:publishedIn/dc:date ?trtndate . }\n    BIND(CONCAT(STR(?trtnt), \">\", COALESCE(?trtndate, \"\")) AS ?trtn)\n  }\n  OPTIONAL {\n    ?citetnt trt:citesTaxonName ?tn .\n    OPTIONAL { ?citetnt trt:publishedIn/dc:date ?citetndate . }\n    BIND(CONCAT(STR(?citetnt), \">\", COALESCE(?citetndate, \"\")) AS ?citetn)\n  }\n\n  OPTIONAL {\n    ?augt trt:augmentsTaxonConcept ?tc .\n    OPTIONAL { ?augt trt:publishedIn/dc:date ?augdate . }\n    BIND(CONCAT(STR(?augt), \">\", COALESCE(?augdate, \"\")) AS ?aug)\n  }\n  OPTIONAL {\n    ?deft trt:definesTaxonConcept ?tc .\n    OPTIONAL { ?deft trt:publishedIn/dc:date ?defdate . }\n    BIND(CONCAT(STR(?deft), \">\", COALESCE(?defdate, \"\")) AS ?def)\n  }\n  OPTIONAL {\n    ?dprt trt:deprecates ?tc .\n    OPTIONAL { ?dprt trt:publishedIn/dc:date ?dprdate . }\n        BIND(CONCAT(STR(?dprt), \">\", COALESCE(?dprdate, \"\")) AS ?dpr)\n  }\n  OPTIONAL {\n    ?citet cito:cites ?tc . \n    OPTIONAL { ?citet trt:publishedIn/dc:date ?citedate . }\n        BIND(CONCAT(STR(?citet), \">\", COALESCE(?citedate, \"\")) AS ?cite)\n  }\n}\nGROUP BY ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\nLIMIT 500`;\n    // For unclear reasons, the query breaks if the limit is removed.\n\n    if (this.controller.signal?.aborted) return Promise.reject();\n\n    /// ?tn ?tc ?col !rank !genus ?species ?infrasp !name !authority ?tcAuth\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `NameFromTC ${tcUri}`,\n    );\n\n    await this.handleName(json, justification);\n  }\n\n  /** @internal */\n  private async getNameFromTN(\n    tnUri: string,\n    justification: Justification,\n  ): Promise<void> {\n    // Note: this query assumes that there is no sub-species taxa with missing dwc:species\n    // Note: the handling assumes that at most one taxon-name matches this colTaxon\n    const query = `\nPREFIX dc: <http://purl.org/dc/elements/1.1/>\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nPREFIX dwcFP: <http://filteredpush.org/ontologies/oa/dwcFP#>\nPREFIX cito: <http://purl.org/spar/cito/>\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\n  (group_concat(DISTINCT ?tcauth;separator=\" / \") AS ?tcAuth)\n  (group_concat(DISTINCT ?aug;separator=\"|\") as ?augs)\n  (group_concat(DISTINCT ?def;separator=\"|\") as ?defs)\n  (group_concat(DISTINCT ?dpr;separator=\"|\") as ?dprs)\n  (group_concat(DISTINCT ?cite;separator=\"|\") as ?cites)\n  (group_concat(DISTINCT ?trtn;separator=\"|\") as ?tntreats)\n  (group_concat(DISTINCT ?citetn;separator=\"|\") as ?tncites) WHERE {\n  BIND(<${tnUri}> as ?tn)\n  ?tn a dwcFP:TaxonName .\n  ?tn dwc:rank ?rank .\n  ?tn dwc:genus ?genus .\n  ?tn dwc:kingdom ?kingdom .\n  OPTIONAL {\n    ?tn dwc:species ?species .\n    OPTIONAL { ?tn dwc:subspecies|dwc:variety ?infrasp . }\n  }\n  \n  OPTIONAL {\n    ?col dwc:taxonRank ?rank .\n    OPTIONAL { ?col dwc:scientificNameAuthorship ?colAuth . }\n    ?col dwc:scientificName ?fullName . # Note: contains authority\n    ?col dwc:genericName ?genus .\n    # TODO # ?col dwc:parent* ?p . ?p dwc:rank \"kingdom\" ; dwc:taxonName ?kingdom .\n\n    {\n      ?col dwc:specificEpithet ?species .\n      ?tn dwc:species ?species .\n      {\n        ?col dwc:infraspecificEpithet ?infrasp .\n        ?tn dwc:subspecies|dwc:variety ?infrasp .\n      } UNION {\n        FILTER NOT EXISTS { ?col dwc:infraspecificEpithet ?infrasp . }\n        FILTER NOT EXISTS { ?tn dwc:subspecies|dwc:variety ?infrasp . }\n      }\n    } UNION {\n      FILTER NOT EXISTS { ?col dwc:specificEpithet ?species . }\n      FILTER NOT EXISTS { ?tn dwc:species ?species . }\n    }\n  }\n  \n  BIND(COALESCE(?fullName, CONCAT(?genus, COALESCE(CONCAT(\" (\",?subgenus,\")\"), \"\"), COALESCE(CONCAT(\" \",?species), \"\"), COALESCE(CONCAT(\" \", ?infrasp), \"\"))) as ?name)\n  BIND(COALESCE(?colAuth, \"\") as ?authority)\n\n  OPTIONAL {\n    ?trtnt trt:treatsTaxonName ?tn .\n    OPTIONAL { ?trtnt trt:publishedIn/dc:date ?trtndate . }\n    BIND(CONCAT(STR(?trtnt), \">\", COALESCE(?trtndate, \"\")) AS ?trtn)\n  }\n  OPTIONAL {\n    ?citetnt trt:citesTaxonName ?tn .\n    OPTIONAL { ?citetnt trt:publishedIn/dc:date ?citetndate . }\n    BIND(CONCAT(STR(?citetnt), \">\", COALESCE(?citetndate, \"\")) AS ?citetn)\n  }\n\n  OPTIONAL {\n    ?tc trt:hasTaxonName ?tn ;\n        dwc:scientificNameAuthorship ?tcauth ;\n        a dwcFP:TaxonConcept .\n    OPTIONAL {\n      ?augt trt:augmentsTaxonConcept ?tc .\n      OPTIONAL { ?augt trt:publishedIn/dc:date ?augdate . }\n      BIND(CONCAT(STR(?augt), \">\", COALESCE(?augdate, \"\")) AS ?aug)\n    }\n    OPTIONAL {\n      ?deft trt:definesTaxonConcept ?tc .\n      OPTIONAL { ?deft trt:publishedIn/dc:date ?defdate . }\n      BIND(CONCAT(STR(?deft), \">\", COALESCE(?defdate, \"\")) AS ?def)\n    }\n    OPTIONAL {\n      ?dprt trt:deprecates ?tc .\n      OPTIONAL { ?dprt trt:publishedIn/dc:date ?dprdate . }\n          BIND(CONCAT(STR(?dprt), \">\", COALESCE(?dprdate, \"\")) AS ?dpr)\n    }\n    OPTIONAL {\n      ?citet cito:cites ?tc . \n      OPTIONAL { ?citet trt:publishedIn/dc:date ?citedate . }\n          BIND(CONCAT(STR(?citet), \">\", COALESCE(?citedate, \"\")) AS ?cite)\n    }\n  }\n}\nGROUP BY ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\nLIMIT 500`;\n    // For unclear reasons, the query breaks if the limit is removed.\n\n    if (this.controller.signal?.aborted) return Promise.reject();\n\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `NameFromTN ${tnUri}`,\n    );\n\n    return this.handleName(json, justification);\n  }\n\n  /**\n   * Note this makes some assumptions on which variables are present in the bindings\n   *\n   * @internal */\n  private async handleName(\n    json: SparqlJson,\n    justification: Justification,\n  ): Promise<void> {\n    const treatmentPromises: Treatment[] = [];\n\n    const displayName: string = json.results.bindings[0].name!.value\n      .replace(\n        json.results.bindings[0].authority!.value,\n        \"\",\n      ).trim();\n\n    const colName: AuthorizedName | undefined =\n      json.results.bindings[0].col?.value\n        ? {\n          displayName,\n          authority: json.results.bindings[0].authority!.value,\n          colURI: json.results.bindings[0].col.value,\n          treatments: {\n            def: new Set(),\n            aug: new Set(),\n            dpr: new Set(),\n            cite: new Set(),\n          },\n        }\n        : undefined;\n\n    if (colName) {\n      if (this.expanded.has(colName.colURI!)) return;\n      this.expanded.add(colName.colURI!);\n    }\n\n    const authorizedNames = colName ? [colName] : [];\n\n    const taxonNameURI = json.results.bindings[0].tn?.value;\n    if (taxonNameURI) {\n      if (this.expanded.has(taxonNameURI)) return;\n      this.expanded.add(taxonNameURI); //, NameStatus.madeName);\n    }\n\n    for (const t of json.results.bindings) {\n      if (t.tc && t.tcAuth?.value) {\n        if (this.expanded.has(t.tc.value)) {\n          // console.log(\"Abbruch: already known\", t.tc.value);\n          return;\n        }\n        const def = this.makeTreatmentSet(t.defs?.value.split(\"|\"));\n        const aug = this.makeTreatmentSet(t.augs?.value.split(\"|\"));\n        const dpr = this.makeTreatmentSet(t.dprs?.value.split(\"|\"));\n        const cite = this.makeTreatmentSet(t.cites?.value.split(\"|\"));\n        if (\n          colName && t.tcAuth?.value.split(\" / \").includes(colName.authority)\n        ) {\n          colName.authority = t.tcAuth?.value;\n          colName.taxonConceptURI = t.tc.value;\n          colName.treatments = {\n            def,\n            aug,\n            dpr,\n            cite,\n          };\n        } else {\n          authorizedNames.push({\n            displayName,\n            authority: t.tcAuth.value,\n            taxonConceptURI: t.tc.value,\n            treatments: {\n              def,\n              aug,\n              dpr,\n              cite,\n            },\n          });\n        }\n        // this.expanded.set(t.tc.value, NameStatus.madeName);\n        this.expanded.add(t.tc.value);\n\n        def.forEach((t) => treatmentPromises.push(t));\n        aug.forEach((t) => treatmentPromises.push(t));\n        dpr.forEach((t) => treatmentPromises.push(t));\n      }\n    }\n\n    // TODO: handle col-data \"acceptedName\" and stuff\n\n    const treats = this.makeTreatmentSet(\n      json.results.bindings[0].tntreats?.value.split(\"|\"),\n    );\n    treats.forEach((t) => treatmentPromises.push(t));\n\n    const name: Name = {\n      displayName,\n      taxonNameURI,\n      authorizedNames,\n      justification,\n      treatments: {\n        treats,\n        cite: this.makeTreatmentSet(\n          json.results.bindings[0].tncites?.value.split(\"|\"),\n        ),\n      },\n      vernacularNames: taxonNameURI\n        ? this.getVernacular(taxonNameURI)\n        : Promise.resolve(new Map()),\n    };\n\n    let colPromises: Promise<void>[] = [];\n\n    if (colName) {\n      [colName.acceptedColURI, colPromises] = await this.getAcceptedCol(\n        colName.colURI!,\n        name,\n      );\n    }\n\n    this.pushName(name);\n\n    /** Map<synonymUri, Treatment> */\n    const newSynonyms = new Map<string, Treatment>();\n    (await Promise.all(\n      treatmentPromises.map((treat) =>\n        treat.details.then((d): [Treatment, TreatmentDetails] => {\n          return [treat, d];\n        })\n      ),\n    )).map(([treat, d]) => {\n      d.treats.aug.difference(this.expanded).forEach((s) =>\n        newSynonyms.set(s, treat)\n      );\n      d.treats.def.difference(this.expanded).forEach((s) =>\n        newSynonyms.set(s, treat)\n      );\n      d.treats.dpr.difference(this.expanded).forEach((s) =>\n        newSynonyms.set(s, treat)\n      );\n      d.treats.treattn.difference(this.expanded).forEach((s) =>\n        newSynonyms.set(s, treat)\n      );\n    });\n\n    await Promise.allSettled(\n      [\n        ...colPromises,\n        ...[...newSynonyms].map(([n, treatment]) =>\n          this.getName(n, { searchTerm: false, parent: name, treatment })\n        ),\n      ],\n    );\n  }\n\n  /** @internal */\n  private async getAcceptedCol(\n    colUri: string,\n    parent: Name,\n  ): Promise<[string, Promise<void>[]]> {\n    const query = `\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nSELECT DISTINCT ?current ?current_status (GROUP_CONCAT(DISTINCT ?dpr; separator=\"|\") AS ?dprs) WHERE {\n  BIND(<${colUri}> AS ?col)\n  {\n    ?col dwc:acceptedName ?current .\n    ?dpr dwc:acceptedName ?current .\n    ?current dwc:taxonomicStatus ?current_status .\n  } UNION {\n    ?col dwc:taxonomicStatus ?current_status .\n    OPTIONAL { ?dpr dwc:acceptedName ?col . }\n    FILTER NOT EXISTS { ?col dwc:acceptedName ?current . }\n    BIND(?col AS ?current)\n  }\n}\nGROUP BY ?current ?current_status`;\n\n    if (this.acceptedCol.has(colUri)) {\n      return [this.acceptedCol.get(colUri)!, []];\n    }\n\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `AcceptedCol ${colUri}`,\n    );\n\n    const promises: Promise<void>[] = [];\n\n    for (const b of json.results.bindings) {\n      for (const dpr of b.dprs!.value.split(\"|\")) {\n        if (dpr) {\n          if (!this.acceptedCol.has(b.current!.value)) {\n            this.acceptedCol.set(b.current!.value, b.current!.value);\n            promises.push(\n              this.getNameFromCol(b.current!.value, {\n                searchTerm: false,\n                parent,\n              }),\n            );\n          }\n\n          this.acceptedCol.set(dpr, b.current!.value);\n          if (!this.ignoreDeprecatedCoL) {\n            promises.push(\n              this.getNameFromCol(dpr, { searchTerm: false, parent }),\n            );\n          }\n        }\n      }\n    }\n\n    if (json.results.bindings.length === 0) {\n      // the provided colUri is not in CoL\n      // promises === []\n      if (!this.acceptedCol.has(colUri)) {\n        this.acceptedCol.set(colUri, \"INVALID COL\");\n      }\n      return [this.acceptedCol.get(colUri)!, promises];\n    }\n\n    if (!this.acceptedCol.has(colUri)) this.acceptedCol.set(colUri, colUri);\n    return [this.acceptedCol.get(colUri)!, promises];\n  }\n\n  /** @internal */\n  private async getVernacular(uri: string): Promise<vernacularNames> {\n    const result: vernacularNames = new Map();\n    const query =\n      `SELECT DISTINCT ?n WHERE { <${uri}> <http://rs.tdwg.org/dwc/terms/vernacularName> ?n . }`;\n    const bindings = (await this.sparqlEndpoint.getSparqlResultSet(query, {\n      signal: this.controller.signal,\n    }, `Vernacular ${uri}`)).results.bindings;\n    for (const b of bindings) {\n      if (b.n?.value) {\n        if (b.n[\"xml:lang\"]) {\n          if (result.has(b.n[\"xml:lang\"])) {\n            result.get(b.n[\"xml:lang\"])!.push(b.n.value);\n          } else result.set(b.n[\"xml:lang\"], [b.n.value]);\n        } else {\n          if (result.has(\"??\")) result.get(\"??\")!.push(b.n.value);\n          else result.set(\"??\", [b.n.value]);\n        }\n      }\n    }\n    return result;\n  }\n\n  /** @internal\n   *\n   * the supplied \"urls\" must be of the form \"URL>DATE\"\n   */\n  private makeTreatmentSet(urls?: string[]): Set<Treatment> {\n    if (!urls) return new Set<Treatment>();\n    return new Set<Treatment>(\n      urls.filter((url) => !!url).map((url_d) => {\n        const [url, date] = url_d.split(\">\");\n        if (!this.treatments.has(url)) {\n          const details = this.getTreatmentDetails(url);\n          this.treatments.set(url, {\n            url,\n            date: date ? parseInt(date, 10) : undefined,\n            details,\n          });\n        }\n        return this.treatments.get(url) as Treatment;\n      }),\n    );\n  }\n\n  /** @internal */\n  private async getTreatmentDetails(\n    treatmentUri: string,\n  ): Promise<TreatmentDetails> {\n    const query = `\nPREFIX dc: <http://purl.org/dc/elements/1.1/>\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nPREFIX dwcFP: <http://filteredpush.org/ontologies/oa/dwcFP#>\nPREFIX cito: <http://purl.org/spar/cito/>\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT\n  ?date ?title ?mc\n  (group_concat(DISTINCT ?catalogNumber;separator=\" / \") as ?catalogNumbers)\n  (group_concat(DISTINCT ?collectionCode;separator=\" / \") as ?collectionCodes)\n  (group_concat(DISTINCT ?typeStatus;separator=\" / \") as ?typeStatuss)\n  (group_concat(DISTINCT ?countryCode;separator=\" / \") as ?countryCodes)\n  (group_concat(DISTINCT ?stateProvince;separator=\" / \") as ?stateProvinces)\n  (group_concat(DISTINCT ?municipality;separator=\" / \") as ?municipalitys)\n  (group_concat(DISTINCT ?county;separator=\" / \") as ?countys)\n  (group_concat(DISTINCT ?locality;separator=\" / \") as ?localitys)\n  (group_concat(DISTINCT ?verbatimLocality;separator=\" / \") as ?verbatimLocalitys)\n  (group_concat(DISTINCT ?recordedBy;separator=\" / \") as ?recordedBys)\n  (group_concat(DISTINCT ?eventDate;separator=\" / \") as ?eventDates)\n  (group_concat(DISTINCT ?samplingProtocol;separator=\" / \") as ?samplingProtocols)\n  (group_concat(DISTINCT ?decimalLatitude;separator=\" / \") as ?decimalLatitudes)\n  (group_concat(DISTINCT ?decimalLongitude;separator=\" / \") as ?decimalLongitudes)\n  (group_concat(DISTINCT ?verbatimElevation;separator=\" / \") as ?verbatimElevations)\n  (group_concat(DISTINCT ?gbifOccurrenceId;separator=\" / \") as ?gbifOccurrenceIds)\n  (group_concat(DISTINCT ?gbifSpecimenId;separator=\" / \") as ?gbifSpecimenIds)\n  (group_concat(DISTINCT ?creator;separator=\"; \") as ?creators)\n  (group_concat(DISTINCT ?httpUri;separator=\"|\") as ?httpUris)\n  (group_concat(DISTINCT ?aug;separator=\"|\") as ?augs)\n  (group_concat(DISTINCT ?def;separator=\"|\") as ?defs)\n  (group_concat(DISTINCT ?dpr;separator=\"|\") as ?dprs)\n  (group_concat(DISTINCT ?cite;separator=\"|\") as ?cites)\n  (group_concat(DISTINCT ?trttn;separator=\"|\") as ?trttns)\n  (group_concat(DISTINCT ?citetn;separator=\"|\") as ?citetns)\nWHERE {\n  BIND (<${treatmentUri}> as ?treatment)\n  ?treatment dc:creator ?creator .\n  OPTIONAL { ?treatment dc:title ?title }\n  OPTIONAL { ?treatment trt:augmentsTaxonConcept ?aug . }\n  OPTIONAL { ?treatment trt:definesTaxonConcept ?def . }\n  OPTIONAL { ?treatment trt:deprecates ?dpr . }\n  OPTIONAL { ?treatment cito:cites ?cite . ?cite a dwcFP:TaxonConcept . }\n  OPTIONAL { ?treatment trt:treatsTaxonName ?trttn . }\n  OPTIONAL { ?treatment trt:citesTaxonName ?citetn . }\n  OPTIONAL {\n    ?treatment dwc:basisOfRecord ?mc .\n    ?mc dwc:catalogNumber ?catalogNumber .\n    OPTIONAL { ?mc dwc:collectionCode ?collectionCode . }\n    OPTIONAL { ?mc dwc:typeStatus ?typeStatus . }\n    OPTIONAL { ?mc dwc:countryCode ?countryCode . }\n    OPTIONAL { ?mc dwc:stateProvince ?stateProvince . }\n    OPTIONAL { ?mc dwc:municipality ?municipality . }\n    OPTIONAL { ?mc dwc:county ?county . }\n    OPTIONAL { ?mc dwc:locality ?locality . }\n    OPTIONAL { ?mc dwc:verbatimLocality ?verbatimLocality . }\n    OPTIONAL { ?mc dwc:recordedBy ?recordedBy . }\n    OPTIONAL { ?mc dwc:eventDate ?eventDate . }\n    OPTIONAL { ?mc dwc:samplingProtocol ?samplingProtocol . }\n    OPTIONAL { ?mc dwc:decimalLatitude ?decimalLatitude . }\n    OPTIONAL { ?mc dwc:decimalLongitude ?decimalLongitude . }\n    OPTIONAL { ?mc dwc:verbatimElevation ?verbatimElevation . }\n    OPTIONAL { ?mc trt:gbifOccurrenceId ?gbifOccurrenceId . }\n    OPTIONAL { ?mc trt:gbifSpecimenId ?gbifSpecimenId . }\n    OPTIONAL { ?mc trt:httpUri ?httpUri . }\n  }\n}\nGROUP BY ?date ?title ?mc`;\n    if (this.controller.signal.aborted) {\n      return {\n        materialCitations: [],\n        figureCitations: [],\n        treats: {\n          def: new Set(),\n          aug: new Set(),\n          dpr: new Set(),\n          citetc: new Set(),\n          treattn: new Set(),\n          citetn: new Set(),\n        },\n      };\n    }\n    try {\n      const json = await this.sparqlEndpoint.getSparqlResultSet(\n        query,\n        { signal: this.controller.signal },\n        `TreatmentDetails ${treatmentUri}`,\n      );\n      const materialCitations: MaterialCitation[] = json.results.bindings\n        .filter((t) => t.mc && t.catalogNumbers?.value)\n        .map((t) => {\n          const httpUri = t.httpUris?.value?.split(\"|\");\n          return {\n            \"catalogNumber\": t.catalogNumbers!.value,\n            \"collectionCode\": t.collectionCodes?.value || undefined,\n            \"typeStatus\": t.typeStatuss?.value || undefined,\n            \"countryCode\": t.countryCodes?.value || undefined,\n            \"stateProvince\": t.stateProvinces?.value || undefined,\n            \"municipality\": t.municipalitys?.value || undefined,\n            \"county\": t.countys?.value || undefined,\n            \"locality\": t.localitys?.value || undefined,\n            \"verbatimLocality\": t.verbatimLocalitys?.value || undefined,\n            \"recordedBy\": t.recordedBys?.value || undefined,\n            \"eventDate\": t.eventDates?.value || undefined,\n            \"samplingProtocol\": t.samplingProtocols?.value || undefined,\n            \"decimalLatitude\": t.decimalLatitudes?.value || undefined,\n            \"decimalLongitude\": t.decimalLongitudes?.value || undefined,\n            \"verbatimElevation\": t.verbatimElevations?.value || undefined,\n            \"gbifOccurrenceId\": t.gbifOccurrenceIds?.value || undefined,\n            \"gbifSpecimenId\": t.gbifSpecimenIds?.value || undefined,\n            httpUri: httpUri?.length ? httpUri : undefined,\n          };\n        });\n      const figureQuery = `\nPREFIX cito: <http://purl.org/spar/cito/>\nPREFIX fabio: <http://purl.org/spar/fabio/>\nPREFIX dc: <http://purl.org/dc/elements/1.1/>\nSELECT DISTINCT ?url ?description WHERE {\n  <${treatmentUri}> cito:cites ?cites .\n  ?cites a fabio:Figure ;\n  fabio:hasRepresentation ?url .\n  OPTIONAL { ?cites dc:description ?description . }\n} `;\n      const figures = (await this.sparqlEndpoint.getSparqlResultSet(\n        figureQuery,\n        { signal: this.controller.signal },\n        `TreatmentDetails/Figures ${treatmentUri}`,\n      )).results.bindings;\n      const figureCitations = figures.filter((f) => f.url?.value).map(\n        (f) => {\n          return { url: f.url!.value, description: f.description?.value };\n        },\n      );\n      return {\n        creators: json.results.bindings[0]?.creators?.value,\n        title: json.results.bindings[0]?.title?.value,\n        materialCitations,\n        figureCitations,\n        treats: {\n          def: new Set(\n            json.results.bindings[0]?.defs?.value\n              ? json.results.bindings[0].defs.value.split(\"|\")\n              : undefined,\n          ),\n          aug: new Set(\n            json.results.bindings[0]?.augs?.value\n              ? json.results.bindings[0].augs.value.split(\"|\")\n              : undefined,\n          ),\n          dpr: new Set(\n            json.results.bindings[0]?.dprs?.value\n              ? json.results.bindings[0].dprs.value.split(\"|\")\n              : undefined,\n          ),\n          citetc: new Set(\n            json.results.bindings[0]?.cites?.value\n              ? json.results.bindings[0].cites.value.split(\"|\")\n              : undefined,\n          ),\n          treattn: new Set(\n            json.results.bindings[0]?.trttns?.value\n              ? json.results.bindings[0].trttns.value.split(\"|\")\n              : undefined,\n          ),\n          citetn: new Set(\n            json.results.bindings[0]?.citetns?.value\n              ? json.results.bindings[0].citetns.value.split(\"|\")\n              : undefined,\n          ),\n        },\n      };\n    } catch (error) {\n      console.warn(\"SPARQL Error: \" + error);\n      return {\n        materialCitations: [],\n        figureCitations: [],\n        treats: {\n          def: new Set(),\n          aug: new Set(),\n          dpr: new Set(),\n          citetc: new Set(),\n          treattn: new Set(),\n          citetn: new Set(),\n        },\n      };\n    }\n  }\n\n  /** Allows iterating over the synonyms while they are found */\n  [Symbol.asyncIterator](): AsyncIterator<Name> {\n    let returnedSoFar = 0;\n    return {\n      next: () =>\n        new Promise<IteratorResult<Name>>(\n          (resolve, reject) => {\n            const callback = () => {\n              if (this.controller.signal.aborted) {\n                reject(new Error(\"SynyonymGroup has been aborted\"));\n              } else if (returnedSoFar < this.names.length) {\n                resolve({ value: this.names[returnedSoFar++] });\n              } else if (this.isFinished) {\n                resolve({ done: true, value: true });\n              } else {\n                const listener = () => {\n                  this.monitor.removeEventListener(\"updated\", listener);\n                  callback();\n                };\n                this.monitor.addEventListener(\"updated\", listener);\n              }\n            };\n            callback();\n          },\n        ),\n    };\n  }\n}\n\n// TODO: CoL taxa without authority -- associate them with the Name directly\n// eg. 5KTTT is \"Quercus robur subsp. robur\" w/o authority\n\n/** The central object.\n *\n * Each `Name` exists because of a taxon-name, taxon-concept or col-taxon in the data.\n * Each `Name` is uniquely determined by its human-readable latin name (for taxa ranking below genus, this is a multi-part name \u2014 binomial or trinomial) and kingdom.\n */\nexport type Name = {\n  /** taxonomic kingdom */\n  // kingdom: string;\n  /** Human-readable name */\n  displayName: string;\n\n  /** vernacular names */\n  vernacularNames: Promise<vernacularNames>;\n\n  // /** Contains the family tree / upper taxons accorindg to CoL / treatmentbank.\n  //  * //TODO */\n  // trees: Promise<{\n  //   col?: Tree;\n  //   tb?: Tree;\n  // }>;\n\n  /** The URI of the respective `dwcFP:TaxonName` if it exists */\n  taxonNameURI?: string;\n  /** All `AuthorizedName`s with this name */\n  authorizedNames: AuthorizedName[];\n\n  /** How this name was found */\n  justification: Justification;\n\n  /** treatments directly associated with .taxonNameUri */\n  treatments: {\n    treats: Set<Treatment>;\n    cite: Set<Treatment>;\n  };\n};\n\n/**\n * A map from language tags (IETF) to an array of vernacular names.\n */\nexport type vernacularNames = Map<string, string[]>;\n\n/** Why a given Name was found (ther migth be other possible justifications) */\nexport type Justification = {\n  searchTerm: true;\n  /** indicates that this is a subTaxon of the parent */\n  subTaxon: boolean;\n} | {\n  searchTerm: false;\n  parent: Name;\n  /** if missing, indicates synonymy according to CoL or subTaxon */\n  treatment?: Treatment;\n};\n\n/**\n * Corresponds to a taxon-concept or a CoL-Taxon\n */\nexport type AuthorizedName = {\n  // TODO: neccesary?\n  /** this may not be neccesary, as `AuthorizedName`s should only appear within a `Name` */\n  // name: Name;\n  /** Human-readable name */\n  displayName: string;\n  /** Human-readable authority */\n  authority: string;\n\n  /** The URI of the respective `dwcFP:TaxonConcept` if it exists */\n  taxonConceptURI?: string;\n\n  /** The URI of the respective CoL-taxon if it exists */\n  colURI?: string;\n  /** The URI of the corresponding accepted CoL-taxon if it exists.\n   *\n   * Always present if colURI is present, they are the same if it is the accepted CoL-Taxon.\n   *\n   * May be the string \"INVALID COL\" if the colURI is not valid.\n   */\n  acceptedColURI?: string;\n\n  // TODO: sensible?\n  // /** these are CoL-taxa linked in the rdf, which differ lexically */\n  // seeAlsoCol: string[];\n\n  /** treatments directly associated with .taxonConceptURI */\n  treatments: {\n    def: Set<Treatment>;\n    aug: Set<Treatment>;\n    dpr: Set<Treatment>;\n    cite: Set<Treatment>;\n  };\n};\n\n/** A plazi-treatment */\nexport type Treatment = {\n  url: string;\n  date?: number;\n\n  /** Details are behind a promise becuase they are loaded with a separate query. */\n  details: Promise<TreatmentDetails>;\n};\n\n/** Details of a treatment */\nexport type TreatmentDetails = {\n  materialCitations: MaterialCitation[];\n  figureCitations: FigureCitation[];\n  creators?: string;\n  title?: string;\n  treats: {\n    def: Set<string>;\n    aug: Set<string>;\n    dpr: Set<string>;\n    citetc: Set<string>;\n    treattn: Set<string>;\n    citetn: Set<string>;\n  };\n};\n\n/** A cited material */\nexport type MaterialCitation = {\n  \"catalogNumber\": string;\n  \"collectionCode\"?: string;\n  \"typeStatus\"?: string;\n  \"countryCode\"?: string;\n  \"stateProvince\"?: string;\n  \"municipality\"?: string;\n  \"county\"?: string;\n  \"locality\"?: string;\n  \"verbatimLocality\"?: string;\n  \"recordedBy\"?: string;\n  \"eventDate\"?: string;\n  \"samplingProtocol\"?: string;\n  \"decimalLatitude\"?: string;\n  \"decimalLongitude\"?: string;\n  \"verbatimElevation\"?: string;\n  \"gbifOccurrenceId\"?: string;\n  \"gbifSpecimenId\"?: string;\n  \"httpUri\"?: string[];\n};\n\n/** A cited figure */\nexport type FigureCitation = {\n  url: string;\n  description?: string;\n};\n", "/// <reference lib=\"dom\" />\nimport {\n  type Name,\n  SparqlEndpoint,\n  SynonymGroup,\n  type Treatment,\n} from \"../mod.ts\";\n\nconst params = new URLSearchParams(document.location.search);\nconst HIDE_COL_ONLY_SYNONYMS = !params.has(\"show_col\");\nconst START_WITH_SUBTAXA = params.has(\"subtaxa\");\nconst SORT_TREATMENTS_BY_TYPE = params.has(\"sort_treatments_by_type\");\nconst ENDPOINT_URL = params.get(\"server\") ||\n  \"https://treatment.ld.plazi.org/sparql\";\nconst NAME = params.get(\"q\") ||\n  \"https://www.catalogueoflife.org/data/taxon/3WD9M\";\n\nconst root = document.getElementById(\"root\") as HTMLDivElement;\n\nenum SynoStatus {\n  Def = \"def\",\n  Aug = \"aug\",\n  Dpr = \"dpr\",\n  Cite = \"cite\",\n  Full = \"full\",\n}\n\nconst icons = {\n  def:\n    `<svg class=\"green\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"M17,13H13V17H11V13H7V11H11V7H13V11H17M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z\"/></svg>`,\n  aug:\n    `<svg class=\"blue\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z\"/></svg>`,\n  dpr:\n    `<svg class=\"red\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z\"/></svg>`,\n  cite:\n    `<svg class=\"gray\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z\"/></svg>`,\n  unknown:\n    `<svg class=\"gray\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z\"/></svg>`,\n\n  link:\n    `<svg class=\"gray\" viewBox=\"0 0 24 24\"><path fill=\"currentColor\" d=\"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z\"/></svg>`,\n  east:\n    `<svg class=\"gray\" viewBox=\"0 0 24 24\"><path fill=\"currentColor\" d=\"M15,5l-1.41,1.41L18.17,11H2V13h16.17l-4.59,4.59L15,19l7-7L15,5z\"/></svg>`,\n  west:\n    `<svg class=\"gray\" viewBox=\"0 0 24 24\"><path fill=\"currentColor\" d=\"M9,19l1.41-1.41L5.83,13H22V11H5.83l4.59-4.59L9,5l-7,7L9,19z\"/></svg>`,\n  line:\n    `<svg class=\"gray\" viewBox=\"0 0 24 24\"><rect fill=\"currentColor\" height=\"2\" width=\"16\" x=\"4\" y=\"11\"/></svg>`,\n  empty: `<svg viewBox=\"0 0 24 24\"></svg>`,\n};\n\nclass SynoTreatment extends HTMLElement {\n  constructor(trt: Treatment, status: SynoStatus) {\n    super();\n\n    if (status === SynoStatus.Full) this.classList.add(\"expanded\");\n    else {\n      this.innerHTML = icons[status] ?? icons.unknown;\n      this.addEventListener(\"click\", () => {\n        // const expanded = new SynoTreatment(trt, SynoStatus.Full);\n        // this.prepend(expanded);\n        // expanded.addEventListener(\"click\", () => expanded.remove());\n        this.classList.toggle(\"expanded\");\n      });\n    }\n\n    const date = document.createElement(\"span\");\n    if (trt.date) date.innerText = \"\" + trt.date;\n    else {\n      date.classList.add(\"missing\");\n      date.innerText = \"No Date\";\n    }\n    this.append(date);\n\n    const creators = document.createElement(\"span\");\n    creators.innerText = \"\u2026\";\n    this.append(\": \", creators);\n\n    const title = document.createElement(\"i\");\n    title.innerText = \"\u2026\";\n    this.append(\" \", title);\n\n    const url = document.createElement(\"a\");\n    url.classList.add(\"treatment\", \"uri\");\n    url.href = trt.url;\n    url.innerText = trt.url.replace(\"http://treatment.plazi.org/id/\", \"\");\n    url.innerHTML += icons.link;\n    this.append(\" \", url);\n\n    const names = document.createElement(\"div\");\n    names.classList.add(\"indent\", \"details\");\n    this.append(names);\n\n    trt.details.then((details) => {\n      if (details.creators) creators.innerText = details.creators;\n      else {\n        creators.classList.add(\"missing\");\n        creators.innerText = \"No Authors\";\n      }\n\n      if (details.title) title.innerText = \"\u201C\" + details.title + \"\u201D\";\n      else {\n        title.classList.add(\"missing\");\n        title.innerText = \"No Title\";\n      }\n\n      if (details.treats.def.size > 0) {\n        const line = document.createElement(\"div\");\n        // line.innerHTML = status === SynoStatus.Cite ? icons.line : icons.east;\n        line.innerHTML = icons.east;\n        line.innerHTML += icons.def;\n        if (status === SynoStatus.Def || status === SynoStatus.Cite) {\n          line.classList.add(\"hidden\");\n        }\n        names.append(line);\n\n        details.treats.def.forEach((n) => {\n          const url = document.createElement(\"code\");\n          url.classList.add(\"taxon\", \"uri\");\n          url.innerText = n.replace(\"http://taxon-concept.plazi.org/id/\", \"\");\n          line.append(url);\n        });\n      }\n      if (details.treats.aug.size > 0 || details.treats.treattn.size > 0) {\n        const line = document.createElement(\"div\");\n        // line.innerHTML = status === SynoStatus.Cite ? icons.line : icons.east;\n        line.innerHTML = icons.east;\n        line.innerHTML += icons.aug;\n        if (status === SynoStatus.Aug || status === SynoStatus.Cite) {\n          line.classList.add(\"hidden\");\n        }\n        names.append(line);\n\n        details.treats.aug.forEach((n) => {\n          const url = document.createElement(\"code\");\n          url.classList.add(\"taxon\", \"uri\");\n          url.innerText = n.replace(\"http://taxon-concept.plazi.org/id/\", \"\");\n          line.append(url);\n        });\n        details.treats.treattn.forEach((n) => {\n          const url = document.createElement(\"code\");\n          url.classList.add(\"taxon\", \"uri\");\n          url.innerText = n.replace(\"http://taxon-name.plazi.org/id/\", \"\");\n          line.append(url);\n        });\n      }\n      if (details.treats.dpr.size > 0) {\n        const line = document.createElement(\"div\");\n        // line.innerHTML = status === SynoStatus.Cite ? icons.line : icons.west;\n        line.innerHTML = icons.west;\n        line.innerHTML += icons.dpr;\n        if (status === SynoStatus.Dpr || status === SynoStatus.Cite) {\n          line.classList.add(\"hidden\");\n        }\n        names.append(line);\n\n        details.treats.dpr.forEach((n) => {\n          const url = document.createElement(\"code\");\n          url.classList.add(\"taxon\", \"uri\");\n          url.innerText = n.replace(\"http://taxon-concept.plazi.org/id/\", \"\");\n          line.append(url);\n        });\n      }\n      if (details.treats.citetc.size > 0 || details.treats.citetn.size > 0) {\n        const line = document.createElement(\"div\");\n        line.innerHTML = icons.empty + icons.cite;\n        // if (status === SynoStatus.Dpr || status === SynoStatus.Cite) {\n        line.classList.add(\"hidden\");\n        // }\n        names.append(line);\n\n        details.treats.citetc.forEach((n) => {\n          const url = document.createElement(\"code\");\n          url.classList.add(\"taxon\", \"uri\");\n          url.innerText = n.replace(\"http://taxon-concept.plazi.org/id/\", \"\");\n          line.append(url);\n        });\n        details.treats.citetn.forEach((n) => {\n          const url = document.createElement(\"code\");\n          url.classList.add(\"taxon\", \"uri\");\n          url.innerText = n.replace(\"http://taxon-name.plazi.org/id/\", \"\");\n          line.append(url);\n        });\n      }\n    });\n  }\n}\ncustomElements.define(\"syno-treatment\", SynoTreatment);\n\nclass SynoName extends HTMLElement {\n  constructor(name: Name) {\n    super();\n\n    const title = document.createElement(\"h2\");\n    const name_title = document.createElement(\"i\");\n    name_title.innerText = name.displayName;\n    title.append(name_title);\n    this.append(title);\n\n    if (name.taxonNameURI) {\n      const name_uri = document.createElement(\"code\");\n      name_uri.classList.add(\"taxon\", \"uri\");\n      name_uri.innerText = name.taxonNameURI.replace(\n        \"http://taxon-name.plazi.org/id/\",\n        \"\",\n      );\n      name_uri.title = name.taxonNameURI;\n      title.append(name_uri);\n    }\n\n    const justification = document.createElement(\"abbr\");\n    justification.classList.add(\"justification\");\n    justification.innerText = \"...?\";\n    justify(name).then((just) => justification.title = `This ${just}`);\n    title.append(justification);\n\n    const vernacular = document.createElement(\"code\");\n    vernacular.classList.add(\"vernacular\");\n    name.vernacularNames.then((names) => {\n      if (names.size > 0) {\n        vernacular.innerText = \"\u201C\" + [...names.values()].join(\"\u201D, \u201C\") + \"\u201D\";\n      }\n    });\n    this.append(vernacular);\n\n    if (name.treatments.treats.size > 0 || name.treatments.cite.size > 0) {\n      const treatments = document.createElement(\"ul\");\n      this.append(treatments);\n      for (const trt of name.treatments.treats) {\n        const li = new SynoTreatment(trt, SynoStatus.Aug);\n        treatments.append(li);\n      }\n      for (const trt of name.treatments.cite) {\n        const li = new SynoTreatment(trt, SynoStatus.Cite);\n        treatments.append(li);\n      }\n    }\n\n    for (const authorizedName of name.authorizedNames) {\n      const authName = document.createElement(\"h3\");\n      const name_title = document.createElement(\"i\");\n      name_title.innerText = authorizedName.displayName;\n      name_title.classList.add(\"gray\");\n      authName.append(name_title);\n      authName.append(\" \", authorizedName.authority);\n      this.append(authName);\n\n      const treatments = document.createElement(\"ul\");\n      this.append(treatments);\n\n      if (authorizedName.taxonConceptURI) {\n        const name_uri = document.createElement(\"code\");\n        name_uri.classList.add(\"taxon\", \"uri\");\n        name_uri.innerText = authorizedName.taxonConceptURI.replace(\n          \"http://taxon-concept.plazi.org/id/\",\n          \"\",\n        );\n        name_uri.title = authorizedName.taxonConceptURI;\n        authName.append(name_uri);\n      }\n      if (authorizedName.colURI) {\n        const col_uri = document.createElement(\"code\");\n        col_uri.classList.add(\"col\", \"uri\");\n        const id = authorizedName.colURI.replace(\n          \"https://www.catalogueoflife.org/data/taxon/\",\n          \"\",\n        );\n        col_uri.innerText = id;\n        col_uri.id = id;\n        col_uri.title = authorizedName.colURI;\n        authName.append(col_uri);\n\n        const li = document.createElement(\"div\");\n        li.classList.add(\"treatmentline\");\n        li.innerHTML = authorizedName.acceptedColURI !== authorizedName.colURI\n          ? icons.dpr\n          : icons.aug;\n        treatments.append(li);\n\n        const creators = document.createElement(\"span\");\n        creators.innerText = \"Catalogue of Life\";\n        li.append(creators);\n\n        const names = document.createElement(\"div\");\n        names.classList.add(\"indent\");\n        li.append(names);\n\n        if (authorizedName.acceptedColURI !== authorizedName.colURI) {\n          const line = document.createElement(\"div\");\n          line.innerHTML = icons.east + icons.aug;\n          names.append(line);\n\n          const col_uri = document.createElement(\"a\");\n          col_uri.classList.add(\"col\", \"uri\");\n          const id = authorizedName.acceptedColURI!.replace(\n            \"https://www.catalogueoflife.org/data/taxon/\",\n            \"\",\n          );\n          col_uri.innerText = id;\n          col_uri.href = `#${id}`;\n          col_uri.title = authorizedName.acceptedColURI!;\n          line.append(col_uri);\n        }\n      }\n\n      const treatments_array: { trt: Treatment; status: SynoStatus }[] = [];\n\n      for (const trt of authorizedName.treatments.def) {\n        treatments_array.push({ trt, status: SynoStatus.Def });\n      }\n      for (const trt of authorizedName.treatments.aug) {\n        treatments_array.push({ trt, status: SynoStatus.Aug });\n      }\n      for (const trt of authorizedName.treatments.dpr) {\n        treatments_array.push({ trt, status: SynoStatus.Dpr });\n      }\n      for (const trt of authorizedName.treatments.cite) {\n        treatments_array.push({ trt, status: SynoStatus.Cite });\n      }\n\n      if (!SORT_TREATMENTS_BY_TYPE) {\n        treatments_array.sort((a, b) => {\n          if (a.trt.date && b.trt.date) return a.trt.date - b.trt.date;\n          if (a.trt.date) return 1;\n          if (b.trt.date) return -1;\n          return 0;\n        });\n      }\n\n      for (const { trt, status } of treatments_array) {\n        const li = new SynoTreatment(trt, status);\n        treatments.append(li);\n      }\n    }\n  }\n}\ncustomElements.define(\"syno-name\", SynoName);\n\nasync function justify(name: Name): Promise<string> {\n  if (name.justification.searchTerm) {\n    if (name.justification.subTaxon) {\n      return \"is a sub-taxon of the search term.\";\n    } else return \"is the search term.\";\n  } else if (name.justification.treatment) {\n    const details = await name.justification.treatment.details;\n    const parent = await justify(name.justification.parent);\n    return `is, according to ${details.creators} ${name.justification.treatment.date},\\n     a synonym of ${name.justification.parent.displayName} which ${parent}`;\n    // return `is, according to ${details.creators} ${details.date} \u201C${details.title||\"No Title\"}\u201D ${name.justification.treatment.url},\\n     a synonym of ${name.justification.parent.displayName} which ${parent}`;\n  } else {\n    const parent = await justify(name.justification.parent);\n    return `is, according to the Catalogue of Life,\\n     a synonym of ${name.justification.parent.displayName} which ${parent}`;\n  }\n}\n\nconst indicator = document.createElement(\"div\");\nroot.insertAdjacentElement(\"beforebegin\", indicator);\nindicator.append(`Finding Synonyms for ${NAME} `);\nindicator.append(document.createElement(\"progress\"));\n\nconst timeStart = performance.now();\n\nconst sparqlEndpoint = new SparqlEndpoint(ENDPOINT_URL);\nconst synoGroup = new SynonymGroup(\n  sparqlEndpoint,\n  NAME,\n  HIDE_COL_ONLY_SYNONYMS,\n  START_WITH_SUBTAXA,\n);\n\nfor await (const name of synoGroup) {\n  const element = new SynoName(name);\n  root.append(element);\n}\n\nconst timeEnd = performance.now();\n\nindicator.innerHTML = \"\";\nindicator.innerText =\n  `Found ${synoGroup.names.length} names with ${synoGroup.treatments.size} treatments. This took ${\n    (timeEnd - timeStart) / 1000\n  } seconds.`;\nif (synoGroup.names.length === 0) root.append(\":[\");\n"],
  "mappings": "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",
  "names": ["sleep", "ms", "resolve", "SparqlEndpoint", "sparqlEnpointUri", "query", "fetchOptions", "_reason", "retryCount", "sendRequest", "response", "error", "wait", "SynonymGroup", "name", "sparqlEndpoint", "taxonName", "ignoreDeprecatedCoL", "startWithSubTaxa", "justification", "url", "query", "names", "n", "genus", "species", "infrasp", "colUri", "json", "tcUri", "tnUri", "treatmentPromises", "displayName", "colName", "authorizedNames", "taxonNameURI", "t", "def", "aug", "dpr", "cite", "treats", "colPromises", "newSynonyms", "treat", "d", "s", "treatment", "parent", "promises", "b", "uri", "result", "bindings", "urls", "url_d", "date", "details", "treatmentUri", "materialCitations", "httpUri", "figureQuery", "figureCitations", "f", "error", "returnedSoFar", "resolve", "reject", "callback", "listener", "params", "HIDE_COL_ONLY_SYNONYMS", "START_WITH_SUBTAXA", "SORT_TREATMENTS_BY_TYPE", "ENDPOINT_URL", "NAME", "root", "icons", "SynoTreatment", "trt", "status", "date", "creators", "title", "url", "names", "details", "line", "n", "SynoName", "name", "name_title", "name_uri", "justification", "justify", "just", "vernacular", "treatments", "li", "authorizedName", "authName", "col_uri", "id", "treatments_array", "SORT_TREATMENTS_BY_TYPE", "a", "b", "parent", "indicator", "root", "NAME", "timeStart", "sparqlEndpoint", "SparqlEndpoint", "ENDPOINT_URL", "synoGroup", "SynonymGroup", "HIDE_COL_ONLY_SYNONYMS", "START_WITH_SUBTAXA", "element", "timeEnd"]
}

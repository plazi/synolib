{
  "version": 3,
  "sources": ["../SparqlEndpoint.ts", "../SynonymGroup.ts", "https://jsr.io/@std/collections/1.0.9/distinct.ts", "index.ts"],
  "sourcesContent": ["async function sleep(ms: number): Promise<void> {\n  const p = new Promise<void>((resolve) => {\n    setTimeout(resolve, ms);\n  });\n  return await p;\n}\n\n/** Describes the format of the JSON return by SPARQL endpoints */\nexport type SparqlJson = {\n  head: {\n    vars: string[];\n  };\n  results: {\n    bindings: {\n      [key: string]:\n        | { type: string; value: string; \"xml:lang\"?: string }\n        | undefined;\n    }[];\n  };\n};\n\n/**\n * Represents a remote sparql endpoint and provides a uniform way to run queries.\n */\nexport class SparqlEndpoint {\n  /** Create a new SparqlEndpoint with the given URI */\n  constructor(private sparqlEnpointUri: string) {}\n\n  /** @ignore */\n  // reasons: string[] = [];\n\n  /**\n   * Run a query against the sparql endpoint\n   *\n   * It automatically retries up to 10 times on fetch errors, waiting 50ms on the first retry and doupling the wait each time.\n   * Retries are logged to the console (`console.warn`)\n   *\n   * @throws In case of non-ok response status codes or if fetch failed 10 times.\n   * @param query The sparql query to run against the endpoint\n   * @param fetchOptions Additional options for the `fetch` request\n   * @param _reason (Currently ignored, used internally for debugging purposes)\n   * @returns Results of the query\n   */\n  async getSparqlResultSet(\n    query: string,\n    fetchOptions: RequestInit = {},\n    _reason = \"\",\n  ): Promise<SparqlJson> {\n    // this.reasons.push(_reason);\n\n    fetchOptions.headers = fetchOptions.headers || {};\n    (fetchOptions.headers as Record<string, string>)[\"Accept\"] =\n      \"application/sparql-results+json\";\n    let retryCount = 0;\n    const sendRequest = async (): Promise<SparqlJson> => {\n      try {\n        // console.info(`SPARQL ${_reason} (${retryCount + 1})`);\n        const response = await fetch(\n          this.sparqlEnpointUri + \"?query=\" + encodeURIComponent(query),\n          fetchOptions,\n        );\n        if (!response.ok) {\n          throw new Error(\"Response not ok. Status \" + response.status);\n        }\n        return await response.json();\n      } catch (error) {\n        if (fetchOptions.signal?.aborted) {\n          throw error;\n        } else if (retryCount < 10) {\n          const wait = 50 * (1 << retryCount++);\n          console.warn(`!! Fetch Error. Retrying in ${wait}ms (${retryCount})`);\n          await sleep(wait);\n          return await sendRequest();\n        }\n        console.warn(\"!! Fetch Error:\", query, \"\\n---\\n\", error);\n        throw error;\n      }\n    };\n    return await sendRequest();\n  }\n}\n", "import type { SparqlEndpoint, SparqlJson } from \"./mod.ts\";\n\n/** Finds all synonyms of a taxon */\nexport class SynonymGroup implements AsyncIterable<Name> {\n  /** Indicates whether the SynonymGroup has found all synonyms.\n   *\n   * @readonly\n   */\n  isFinished = false;\n  /** Used internally to watch for new names found */\n  private monitor: EventTarget = new EventTarget();\n\n  /** Used internally to abort in-flight network requests when SynonymGroup is aborted */\n  private controller = new AbortController();\n\n  /** The SparqlEndpoint used */\n  private sparqlEndpoint: SparqlEndpoint;\n\n  /**\n   * List of names found so-far.\n   *\n   * Contains full list of synonyms _if_ .isFinished and not .isAborted\n   *\n   * @readonly\n   */\n  names: Name[] = [];\n  /**\n   * Add a new Name to this.names.\n   *\n   * Note: does not deduplicate on its own\n   *\n   * @internal */\n  private pushName(name: Name) {\n    this.names.push(name);\n    this.monitor.dispatchEvent(new CustomEvent(\"updated\"));\n  }\n\n  /**\n   * Call when all synonyms are found\n   *\n   * @internal */\n  private finish() {\n    this.isFinished = true;\n    this.monitor.dispatchEvent(new CustomEvent(\"updated\"));\n  }\n\n  /** contains TN, TC, CoL uris of synonyms which are in-flight somehow or are done already */\n  private expanded = new Set<string>(); // new Map<string, NameStatus>();\n\n  /** contains CoL uris where we don't need to check for Col \"acceptedName\" links\n   *\n   * col -> accepted col\n   */\n  private acceptedCol = new Map<string, string>();\n\n  /**\n   * Used internally to deduplicate treatments, maps from URI to Object.\n   *\n   * Contains full list of treatments _if_ .isFinished and not .isAborted\n   *\n   * @readonly\n   */\n  treatments: Map<string, Treatment> = new Map();\n\n  /**\n   * Whether to show taxa deprecated by CoL that would not have been found otherwise.\n   * This significantly increases the number of results in some cases.\n   */\n  ignoreDeprecatedCoL: boolean;\n\n  /**\n   * if set to true, subTaxa of the search term are also considered as starting points.\n   *\n   * Not that \"weird\" ranks like subGenus are always included when searching for a genus by latin name.\n   */\n  startWithSubTaxa: boolean;\n\n  /**\n   * Constructs a SynonymGroup\n   *\n   * @param sparqlEndpoint SPARQL-Endpoint to query\n   * @param taxonName either a string of the form \"Genus species infraspecific\" (species & infraspecific names optional), or an URI of a http://filteredpush.org/ontologies/oa/dwcFP#TaxonConcept or ...#TaxonName or a CoL taxon URI\n   * @param [ignoreDeprecatedCoL=true] Whether to show taxa deprecated by CoL that would not have been found otherwise\n   * @param [startWithSubTaxa=false] if set to true, subTaxa of the search term are also considered as starting points.\n   */\n  constructor(\n    sparqlEndpoint: SparqlEndpoint,\n    taxonName: string,\n    ignoreDeprecatedCoL = true,\n    startWithSubTaxa = false,\n  ) {\n    this.sparqlEndpoint = sparqlEndpoint;\n    this.ignoreDeprecatedCoL = ignoreDeprecatedCoL;\n    this.startWithSubTaxa = startWithSubTaxa;\n\n    if (taxonName.startsWith(\"http\")) {\n      this.getName(taxonName, { searchTerm: true, subTaxon: false })\n        .catch((e) => {\n          console.log(\"SynoGroup Failure: \", e);\n          this.controller.abort(\"SynoGroup Failed\");\n        })\n        .finally(() => this.finish());\n    } else {\n      const name = [\n        ...taxonName.split(\" \").filter((n) => !!n),\n        undefined,\n        undefined,\n      ] as [string, string | undefined, string | undefined];\n      this.getNameFromLatin(name, { searchTerm: true, subTaxon: false })\n        .finally(\n          () => this.finish(),\n        );\n    }\n  }\n\n  /** @internal */\n  private async getName(\n    taxonName: string,\n    justification: Justification,\n  ): Promise<void> {\n    if (this.expanded.has(taxonName)) {\n      console.log(\"Skipping known\", taxonName);\n      return;\n    }\n\n    if (taxonName.startsWith(\"https://www.catalogueoflife.org\")) {\n      await this.getNameFromCol(taxonName, justification);\n    } else if (taxonName.startsWith(\"http://taxon-concept.plazi.org\")) {\n      await this.getNameFromTC(taxonName, justification);\n    } else if (taxonName.startsWith(\"http://taxon-name.plazi.org\")) {\n      await this.getNameFromTN(taxonName, justification);\n    } else {\n      throw `Cannot handle name-uri <${taxonName}> !`;\n    }\n\n    if (\n      this.startWithSubTaxa && justification.searchTerm &&\n      !justification.subTaxon\n    ) {\n      await this.getSubtaxa(taxonName);\n    }\n  }\n\n  /** @internal */\n  private async getSubtaxa(url: string): Promise<void> {\n    const query = url.startsWith(\"http://taxon-concept.plazi.org\")\n      ? `\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT ?sub WHERE {\n  BIND(<${url}> as ?url)\n  ?sub trt:hasParentName*/^trt:hasTaxonName ?url .\n}\nLIMIT 5000`\n      : `\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT ?sub WHERE {\n  BIND(<${url}> as ?url)\n  ?sub (dwc:parent|trt:hasParentName)* ?url .\n}\nLIMIT 5000`;\n\n    if (this.controller.signal?.aborted) return Promise.reject();\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `Subtaxa ${url}`,\n    );\n\n    const names = json.results.bindings\n      .map((n) => n.sub?.value)\n      .filter((n) => n && !this.expanded.has(n)) as string[];\n\n    await Promise.allSettled(\n      names.map((n) => this.getName(n, { searchTerm: true, subTaxon: true })),\n    );\n  }\n\n  /** @internal */\n  private async getNameFromLatin(\n    [genus, species, infrasp]: [string, string | undefined, string | undefined],\n    justification: Justification,\n  ): Promise<void> {\n    const query = `\n    PREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nSELECT DISTINCT ?uri WHERE {\n  ?uri dwc:genus|dwc:genericName \"${genus}\" .\n  ${\n      species\n        ? `?uri dwc:species|dwc:specificEpithet \"${species}\" .`\n        : \"FILTER NOT EXISTS { ?uri dwc:species|dwc:specificEpithet ?species . }\"\n    }\n  ${\n      infrasp\n        ? `?uri dwc:subSpecies|dwc:variety|dwc:form|dwc:infraspecificEpithet \"${infrasp}\" .`\n        : \"FILTER NOT EXISTS { ?uri dwc:subSpecies|dwc:variety|dwc:form|dwc:infraspecificEpithet ?infrasp . }\"\n    }\n}\nLIMIT 500`;\n\n    if (this.controller.signal?.aborted) return Promise.reject();\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `NameFromLatin ${genus} ${species} ${infrasp}`,\n    );\n\n    const names = json.results.bindings\n      .map((n) => n.uri?.value)\n      .filter((n) => n && !this.expanded.has(n)) as string[];\n\n    await Promise.allSettled(names.map((n) => this.getName(n, justification)));\n  }\n\n  /** @internal */\n  private async getNameFromCol(\n    colUri: string,\n    justification: Justification,\n  ): Promise<void> {\n    // Note: this query assumes that there is no sub-species taxa with missing dwc:species\n    // Note: the handling assumes that at most one taxon-name matches this colTaxon\n    const query = `\nPREFIX dc: <http://purl.org/dc/elements/1.1/>\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nPREFIX dwcFP: <http://filteredpush.org/ontologies/oa/dwcFP#>\nPREFIX cito: <http://purl.org/spar/cito/>\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\n  (group_concat(DISTINCT ?tcauth;separator=\" / \") AS ?tcAuth)\n  (group_concat(DISTINCT ?aug;separator=\"|\") as ?augs)\n  (group_concat(DISTINCT ?def;separator=\"|\") as ?defs)\n  (group_concat(DISTINCT ?dpr;separator=\"|\") as ?dprs)\n  (group_concat(DISTINCT ?cite;separator=\"|\") as ?cites)\n  (group_concat(DISTINCT ?trtn;separator=\"|\") as ?tntreats)\n  (group_concat(DISTINCT ?citetn;separator=\"|\") as ?tncites) WHERE {\n  BIND(<${colUri}> as ?col)\n  ?col dwc:taxonRank ?rank .\n  OPTIONAL { ?col dwc:scientificNameAuthorship ?colAuth . } BIND(COALESCE(?colAuth, \"\") as ?authority)\n  ?col dwc:scientificName ?name . # Note: contains authority\n  ?col dwc:genericName ?genus .\n  # TODO # ?col dwc:parent* ?p . ?p dwc:rank \"kingdom\" ; dwc:taxonName ?kingdom .\n  OPTIONAL {\n    ?col dwc:specificEpithet ?species .\n    OPTIONAL { ?col dwc:infraspecificEpithet ?infrasp . }\n  }\n\n  OPTIONAL {\n    ?tn dwc:rank ?trank .\n    FILTER(LCASE(?rank) = LCASE(?trank))\n    ?tn dwc:genus ?genus .\n    ?tn dwc:kingdom ?kingdom .\n    {\n      ?col dwc:specificEpithet ?species .\n      ?tn dwc:species ?species .\n      {\n        ?col dwc:infraspecificEpithet ?infrasp .\n        ?tn dwc:subSpecies|dwc:variety|dwc:form ?infrasp .\n      } UNION {\n        FILTER NOT EXISTS { ?col dwc:infraspecificEpithet ?infrasp . }\n        FILTER NOT EXISTS { ?tn dwc:subSpecies|dwc:variety|dwc:form ?infrasp . }\n      }\n    } UNION {\n      FILTER NOT EXISTS { ?col dwc:specificEpithet ?species . }\n      FILTER NOT EXISTS { ?tn dwc:species ?species . }\n    }\n\n    OPTIONAL {\n      ?trtnt trt:treatsTaxonName ?tn .\n      OPTIONAL { ?trtnt trt:publishedIn/dc:date ?trtndate . }\n      BIND(CONCAT(STR(?trtnt), \">\", COALESCE(?trtndate, \"\")) AS ?trtn)\n    }\n    OPTIONAL {\n      ?citetnt trt:citesTaxonName ?tn .\n      OPTIONAL { ?citetnt trt:publishedIn/dc:date ?citetndate . }\n      BIND(CONCAT(STR(?citetnt), \">\", COALESCE(?citetndate, \"\")) AS ?citetn)\n    }\n\n    OPTIONAL {\n      ?tc trt:hasTaxonName ?tn ;\n          dwc:scientificNameAuthorship ?tcauth ;\n          a dwcFP:TaxonConcept .\n      OPTIONAL {\n        ?augt trt:augmentsTaxonConcept ?tc .\n        OPTIONAL { ?augt trt:publishedIn/dc:date ?augdate . }\n        BIND(CONCAT(STR(?augt), \">\", COALESCE(?augdate, \"\")) AS ?aug)\n      }\n      OPTIONAL {\n        ?deft trt:definesTaxonConcept ?tc .\n        OPTIONAL { ?deft trt:publishedIn/dc:date ?defdate . }\n        BIND(CONCAT(STR(?deft), \">\", COALESCE(?defdate, \"\")) AS ?def)\n      }\n      OPTIONAL {\n        ?dprt trt:deprecates ?tc .\n        OPTIONAL { ?dprt trt:publishedIn/dc:date ?dprdate . }\n            BIND(CONCAT(STR(?dprt), \">\", COALESCE(?dprdate, \"\")) AS ?dpr)\n      }\n      OPTIONAL {\n        ?citet cito:cites ?tc . \n        OPTIONAL { ?citet trt:publishedIn/dc:date ?citedate . }\n            BIND(CONCAT(STR(?citet), \">\", COALESCE(?citedate, \"\")) AS ?cite)\n      }\n    }\n  }\n}\nGROUP BY ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\nLIMIT 500`;\n    // For unclear reasons, the query breaks if the limit is removed.\n\n    if (this.controller.signal?.aborted) return Promise.reject();\n\n    /// ?tn ?tc !rank !genus ?species ?infrasp !name !authority ?tcAuth\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `NameFromCol ${colUri}`,\n    );\n\n    return this.handleName(json, justification);\n  }\n\n  /** @internal */\n  private async getNameFromTC(\n    tcUri: string,\n    justification: Justification,\n  ): Promise<void> {\n    // Note: this query assumes that there is no sub-species taxa with missing dwc:species\n    // Note: the handling assumes that at most one taxon-name matches this colTaxon\n    const query = `\nPREFIX dc: <http://purl.org/dc/elements/1.1/>\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nPREFIX dwcFP: <http://filteredpush.org/ontologies/oa/dwcFP#>\nPREFIX cito: <http://purl.org/spar/cito/>\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\n  (group_concat(DISTINCT ?tcauth;separator=\" / \") AS ?tcAuth)\n  (group_concat(DISTINCT ?aug;separator=\"|\") as ?augs)\n  (group_concat(DISTINCT ?def;separator=\"|\") as ?defs)\n  (group_concat(DISTINCT ?dpr;separator=\"|\") as ?dprs)\n  (group_concat(DISTINCT ?cite;separator=\"|\") as ?cites)\n  (group_concat(DISTINCT ?trtn;separator=\"|\") as ?tntreats)\n  (group_concat(DISTINCT ?citetn;separator=\"|\") as ?tncites) WHERE {\n  <${tcUri}> trt:hasTaxonName ?tn .\n  ?tc trt:hasTaxonName ?tn ;\n      dwc:scientificNameAuthorship ?tcauth ;\n      a dwcFP:TaxonConcept .\n\n  ?tn a dwcFP:TaxonName .\n  ?tn dwc:rank ?rank .\n  ?tn dwc:kingdom ?kingdom .\n  ?tn dwc:genus ?genus .\n  OPTIONAL {\n    ?tn dwc:species ?species .\n    OPTIONAL { ?tn dwc:subSpecies|dwc:variety|dwc:form ?infrasp . }\n  }\n  \n  OPTIONAL {\n    ?col dwc:taxonRank ?crank .\n    FILTER(LCASE(?rank) = LCASE(?crank))\n    OPTIONAL { ?col dwc:scientificNameAuthorship ?colAuth . }\n    ?col dwc:scientificName ?fullName . # Note: contains authority\n    ?col dwc:genericName ?genus .\n    # TODO # ?col dwc:parent* ?p . ?p dwc:rank \"kingdom\" ; dwc:taxonName ?kingdom .\n\n    {\n      ?col dwc:specificEpithet ?species .\n      ?tn dwc:species ?species .\n      {\n        ?col dwc:infraspecificEpithet ?infrasp .\n        ?tn dwc:subSpecies|dwc:variety|dwc:form ?infrasp .\n      } UNION {\n        FILTER NOT EXISTS { ?col dwc:infraspecificEpithet ?infrasp . }\n        FILTER NOT EXISTS { ?tn dwc:subSpecies|dwc:variety|dwc:form ?infrasp . }\n      }\n    } UNION {\n      FILTER NOT EXISTS { ?col dwc:specificEpithet ?species . }\n      FILTER NOT EXISTS { ?tn dwc:species ?species . }\n    }\n  }\n  \n  BIND(COALESCE(?fullName, CONCAT(?genus, COALESCE(CONCAT(\" (\",?subgenus,\")\"), \"\"), COALESCE(CONCAT(\" \",?species), \"\"), COALESCE(CONCAT(\" \", ?infrasp), \"\"))) as ?name)\n  BIND(COALESCE(?colAuth, \"\") as ?authority)\n\n  OPTIONAL {\n    ?trtnt trt:treatsTaxonName ?tn .\n    OPTIONAL { ?trtnt trt:publishedIn/dc:date ?trtndate . }\n    BIND(CONCAT(STR(?trtnt), \">\", COALESCE(?trtndate, \"\")) AS ?trtn)\n  }\n  OPTIONAL {\n    ?citetnt trt:citesTaxonName ?tn .\n    OPTIONAL { ?citetnt trt:publishedIn/dc:date ?citetndate . }\n    BIND(CONCAT(STR(?citetnt), \">\", COALESCE(?citetndate, \"\")) AS ?citetn)\n  }\n\n  OPTIONAL {\n    ?augt trt:augmentsTaxonConcept ?tc .\n    OPTIONAL { ?augt trt:publishedIn/dc:date ?augdate . }\n    BIND(CONCAT(STR(?augt), \">\", COALESCE(?augdate, \"\")) AS ?aug)\n  }\n  OPTIONAL {\n    ?deft trt:definesTaxonConcept ?tc .\n    OPTIONAL { ?deft trt:publishedIn/dc:date ?defdate . }\n    BIND(CONCAT(STR(?deft), \">\", COALESCE(?defdate, \"\")) AS ?def)\n  }\n  OPTIONAL {\n    ?dprt trt:deprecates ?tc .\n    OPTIONAL { ?dprt trt:publishedIn/dc:date ?dprdate . }\n        BIND(CONCAT(STR(?dprt), \">\", COALESCE(?dprdate, \"\")) AS ?dpr)\n  }\n  OPTIONAL {\n    ?citet cito:cites ?tc . \n    OPTIONAL { ?citet trt:publishedIn/dc:date ?citedate . }\n        BIND(CONCAT(STR(?citet), \">\", COALESCE(?citedate, \"\")) AS ?cite)\n  }\n}\nGROUP BY ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\nLIMIT 500`;\n    // For unclear reasons, the query breaks if the limit is removed.\n\n    if (this.controller.signal?.aborted) return Promise.reject();\n\n    /// ?tn ?tc ?col !rank !genus ?species ?infrasp !name !authority ?tcAuth\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `NameFromTC ${tcUri}`,\n    );\n\n    await this.handleName(json, justification);\n  }\n\n  /** @internal */\n  private async getNameFromTN(\n    tnUri: string,\n    justification: Justification,\n  ): Promise<void> {\n    // Note: this query assumes that there is no sub-species taxa with missing dwc:species\n    // Note: the handling assumes that at most one taxon-name matches this colTaxon\n    const query = `\nPREFIX dc: <http://purl.org/dc/elements/1.1/>\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nPREFIX dwcFP: <http://filteredpush.org/ontologies/oa/dwcFP#>\nPREFIX cito: <http://purl.org/spar/cito/>\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\n  (group_concat(DISTINCT ?tcauth;separator=\" / \") AS ?tcAuth)\n  (group_concat(DISTINCT ?aug;separator=\"|\") as ?augs)\n  (group_concat(DISTINCT ?def;separator=\"|\") as ?defs)\n  (group_concat(DISTINCT ?dpr;separator=\"|\") as ?dprs)\n  (group_concat(DISTINCT ?cite;separator=\"|\") as ?cites)\n  (group_concat(DISTINCT ?trtn;separator=\"|\") as ?tntreats)\n  (group_concat(DISTINCT ?citetn;separator=\"|\") as ?tncites) WHERE {\n  BIND(<${tnUri}> as ?tn)\n  ?tn a dwcFP:TaxonName .\n  ?tn dwc:rank ?rank .\n  ?tn dwc:genus ?genus .\n  ?tn dwc:kingdom ?kingdom .\n  OPTIONAL {\n    ?tn dwc:species ?species .\n    OPTIONAL { ?tn dwc:subSpecies|dwc:variety|dwc:form ?infrasp . }\n  }\n  \n  OPTIONAL {\n    ?col dwc:taxonRank ?crank .\n    FILTER(LCASE(?rank) = LCASE(?crank))\n    OPTIONAL { ?col dwc:scientificNameAuthorship ?colAuth . }\n    ?col dwc:scientificName ?fullName . # Note: contains authority\n    ?col dwc:genericName ?genus .\n    # TODO # ?col dwc:parent* ?p . ?p dwc:rank \"kingdom\" ; dwc:taxonName ?kingdom .\n\n    {\n      ?col dwc:specificEpithet ?species .\n      ?tn dwc:species ?species .\n      {\n        ?col dwc:infraspecificEpithet ?infrasp .\n        ?tn dwc:subSpecies|dwc:variety|dwc:form ?infrasp .\n      } UNION {\n        FILTER NOT EXISTS { ?col dwc:infraspecificEpithet ?infrasp . }\n        FILTER NOT EXISTS { ?tn dwc:subSpecies|dwc:variety|dwc:form ?infrasp . }\n      }\n    } UNION {\n      FILTER NOT EXISTS { ?col dwc:specificEpithet ?species . }\n      FILTER NOT EXISTS { ?tn dwc:species ?species . }\n    }\n  }\n  \n  BIND(COALESCE(?fullName, CONCAT(?genus, COALESCE(CONCAT(\" (\",?subgenus,\")\"), \"\"), COALESCE(CONCAT(\" \",?species), \"\"), COALESCE(CONCAT(\" \", ?infrasp), \"\"))) as ?name)\n  BIND(COALESCE(?colAuth, \"\") as ?authority)\n\n  OPTIONAL {\n    ?trtnt trt:treatsTaxonName ?tn .\n    OPTIONAL { ?trtnt trt:publishedIn/dc:date ?trtndate . }\n    BIND(CONCAT(STR(?trtnt), \">\", COALESCE(?trtndate, \"\")) AS ?trtn)\n  }\n  OPTIONAL {\n    ?citetnt trt:citesTaxonName ?tn .\n    OPTIONAL { ?citetnt trt:publishedIn/dc:date ?citetndate . }\n    BIND(CONCAT(STR(?citetnt), \">\", COALESCE(?citetndate, \"\")) AS ?citetn)\n  }\n\n  OPTIONAL {\n    ?tc trt:hasTaxonName ?tn ;\n        dwc:scientificNameAuthorship ?tcauth ;\n        a dwcFP:TaxonConcept .\n    OPTIONAL {\n      ?augt trt:augmentsTaxonConcept ?tc .\n      OPTIONAL { ?augt trt:publishedIn/dc:date ?augdate . }\n      BIND(CONCAT(STR(?augt), \">\", COALESCE(?augdate, \"\")) AS ?aug)\n    }\n    OPTIONAL {\n      ?deft trt:definesTaxonConcept ?tc .\n      OPTIONAL { ?deft trt:publishedIn/dc:date ?defdate . }\n      BIND(CONCAT(STR(?deft), \">\", COALESCE(?defdate, \"\")) AS ?def)\n    }\n    OPTIONAL {\n      ?dprt trt:deprecates ?tc .\n      OPTIONAL { ?dprt trt:publishedIn/dc:date ?dprdate . }\n          BIND(CONCAT(STR(?dprt), \">\", COALESCE(?dprdate, \"\")) AS ?dpr)\n    }\n    OPTIONAL {\n      ?citet cito:cites ?tc . \n      OPTIONAL { ?citet trt:publishedIn/dc:date ?citedate . }\n          BIND(CONCAT(STR(?citet), \">\", COALESCE(?citedate, \"\")) AS ?cite)\n    }\n  }\n}\nGROUP BY ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\nLIMIT 500`;\n    // For unclear reasons, the query breaks if the limit is removed.\n\n    if (this.controller.signal?.aborted) return Promise.reject();\n\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `NameFromTN ${tnUri}`,\n    );\n\n    return this.handleName(json, justification);\n  }\n\n  /**\n   * Note this makes some assumptions on which variables are present in the bindings\n   *\n   * @internal */\n  private async handleName(\n    json: SparqlJson,\n    justification: Justification,\n  ): Promise<void> {\n    const treatmentPromises: Treatment[] = [];\n\n    const displayName: string = json.results.bindings[0].name!.value\n      .replace(\n        json.results.bindings[0].authority!.value,\n        \"\",\n      ).trim();\n\n    // Case where the CoL-taxon has no authority. There should only be one of these.\n    let unathorizedCol: string | undefined;\n\n    // there can be multiple CoL-taxa with same latin name, e.g. Leontopodium alpinum has 3T6ZY and 3T6ZX.\n    const authorizedCoLNames: AuthorizedName[] = [];\n    const authorizedTCNames: AuthorizedName[] = [];\n\n    const taxonNameURI = json.results.bindings[0].tn?.value;\n    if (taxonNameURI) {\n      if (this.expanded.has(taxonNameURI)) return;\n      this.expanded.add(taxonNameURI); //, NameStatus.madeName);\n    }\n\n    for (const t of json.results.bindings) {\n      if (t.col) {\n        const colURI = t.col.value;\n        if (!t.authority?.value) {\n          if (this.expanded.has(colURI)) {\n            console.log(\"Skipping known\", colURI);\n            return;\n          }\n          if (unathorizedCol && unathorizedCol !== colURI) {\n            console.log(\"Duplicate unathorized COL:\", unathorizedCol, colURI);\n          }\n          unathorizedCol = colURI;\n        } else if (!authorizedCoLNames.find((e) => e.colURI === colURI)) {\n          if (this.expanded.has(colURI)) {\n            console.log(\"Skipping known\", colURI);\n            return;\n          }\n          authorizedCoLNames.push({\n            displayName,\n            authority: t.authority!.value,\n            colURI: t.col.value,\n            treatments: {\n              def: new Set(),\n              aug: new Set(),\n              dpr: new Set(),\n              cite: new Set(),\n            },\n          });\n        }\n      }\n\n      if (t.tc && t.tcAuth && t.tcAuth.value) {\n        const def = this.makeTreatmentSet(t.defs?.value.split(\"|\"));\n        const aug = this.makeTreatmentSet(t.augs?.value.split(\"|\"));\n        const dpr = this.makeTreatmentSet(t.dprs?.value.split(\"|\"));\n        const cite = this.makeTreatmentSet(t.cites?.value.split(\"|\"));\n\n        const colName = authorizedCoLNames.find((e) =>\n          t.tcAuth!.value.split(\" / \").includes(e.authority)\n        );\n        if (colName) {\n          colName.authority = t.tcAuth?.value;\n          colName.taxonConceptURI = t.tc.value;\n          colName.treatments = {\n            def,\n            aug,\n            dpr,\n            cite,\n          };\n        } else if (this.expanded.has(t.tc.value)) {\n          // console.log(\"Skipping known\", t.tc.value);\n          return;\n        } else {\n          authorizedTCNames.push({\n            displayName,\n            authority: t.tcAuth.value,\n            taxonConceptURI: t.tc.value,\n            treatments: {\n              def,\n              aug,\n              dpr,\n              cite,\n            },\n          });\n        }\n\n        def.forEach((t) => treatmentPromises.push(t));\n        aug.forEach((t) => treatmentPromises.push(t));\n        dpr.forEach((t) => treatmentPromises.push(t));\n      }\n    }\n\n    const treats = this.makeTreatmentSet(\n      json.results.bindings[0].tntreats?.value.split(\"|\"),\n    );\n    treats.forEach((t) => treatmentPromises.push(t));\n\n    const name: Name = {\n      displayName,\n      rank: json.results.bindings[0].rank!.value,\n      taxonNameURI,\n      authorizedNames: [...authorizedCoLNames, ...authorizedTCNames],\n      colURI: unathorizedCol,\n      justification,\n      treatments: {\n        treats,\n        cite: this.makeTreatmentSet(\n          json.results.bindings[0].tncites?.value.split(\"|\"),\n        ),\n      },\n      vernacularNames: taxonNameURI\n        ? this.getVernacular(taxonNameURI)\n        : Promise.resolve(new Map()),\n    };\n\n    for (const authName of name.authorizedNames) {\n      if (authName.colURI) this.expanded.add(authName.colURI);\n      if (authName.taxonConceptURI) this.expanded.add(authName.taxonConceptURI);\n    }\n\n    const colPromises: Promise<void>[] = [];\n\n    if (unathorizedCol) {\n      const [acceptedColURI, promises] = await this.getAcceptedCol(\n        unathorizedCol,\n        name,\n      );\n      name.acceptedColURI = acceptedColURI;\n      colPromises.push(...promises);\n    }\n\n    await Promise.all(\n      authorizedCoLNames.map(async (n) => {\n        const [acceptedColURI, promises] = await this.getAcceptedCol(\n          n.colURI!,\n          name,\n        );\n        n.acceptedColURI = acceptedColURI;\n        colPromises.push(...promises);\n      }),\n    );\n\n    this.pushName(name);\n\n    /** Map<synonymUri, Treatment> */\n    const newSynonyms = new Map<string, Treatment>();\n    (await Promise.all(\n      treatmentPromises.map((treat) =>\n        treat.details.then((d): [Treatment, TreatmentDetails] => {\n          return [treat, d];\n        })\n      ),\n    )).map(([treat, d]) => {\n      d.treats.aug.difference(this.expanded).forEach((s) =>\n        newSynonyms.set(s, treat)\n      );\n      d.treats.def.difference(this.expanded).forEach((s) =>\n        newSynonyms.set(s, treat)\n      );\n      d.treats.dpr.difference(this.expanded).forEach((s) =>\n        newSynonyms.set(s, treat)\n      );\n      d.treats.treattn.difference(this.expanded).forEach((s) =>\n        newSynonyms.set(s, treat)\n      );\n    });\n\n    await Promise.allSettled(\n      [\n        ...colPromises,\n        ...[...newSynonyms].map(([n, treatment]) =>\n          this.getName(n, { searchTerm: false, parent: name, treatment })\n        ),\n      ],\n    );\n  }\n\n  /** @internal */\n  private async getAcceptedCol(\n    colUri: string,\n    parent: Name,\n  ): Promise<[string, Promise<void>[]]> {\n    const query = `\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nSELECT DISTINCT ?current ?current_status (GROUP_CONCAT(DISTINCT ?dpr; separator=\"|\") AS ?dprs) WHERE {\n  BIND(<${colUri}> AS ?col)\n  {\n    ?col dwc:acceptedName ?current .\n    ?dpr dwc:acceptedName ?current .\n    ?current dwc:taxonomicStatus ?current_status .\n  } UNION {\n    ?col dwc:taxonomicStatus ?current_status .\n    OPTIONAL { ?dpr dwc:acceptedName ?col . }\n    FILTER NOT EXISTS { ?col dwc:acceptedName ?current . }\n    BIND(?col AS ?current)\n  }\n}\nGROUP BY ?current ?current_status`;\n\n    if (this.acceptedCol.has(colUri)) {\n      return [this.acceptedCol.get(colUri)!, []];\n    }\n\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `AcceptedCol ${colUri}`,\n    );\n\n    const promises: Promise<void>[] = [];\n\n    for (const b of json.results.bindings) {\n      for (const dpr of b.dprs!.value.split(\"|\")) {\n        if (dpr) {\n          if (!this.acceptedCol.has(b.current!.value)) {\n            this.acceptedCol.set(b.current!.value, b.current!.value);\n            promises.push(\n              this.getNameFromCol(b.current!.value, {\n                searchTerm: false,\n                parent,\n              }),\n            );\n          }\n\n          this.acceptedCol.set(dpr, b.current!.value);\n          if (!this.ignoreDeprecatedCoL) {\n            promises.push(\n              this.getNameFromCol(dpr, { searchTerm: false, parent }),\n            );\n          }\n        }\n      }\n    }\n\n    if (json.results.bindings.length === 0) {\n      // the provided colUri is not in CoL\n      // promises === []\n      if (!this.acceptedCol.has(colUri)) {\n        this.acceptedCol.set(colUri, \"INVALID COL\");\n      }\n      return [this.acceptedCol.get(colUri)!, promises];\n    }\n\n    if (!this.acceptedCol.has(colUri)) this.acceptedCol.set(colUri, colUri);\n    return [this.acceptedCol.get(colUri)!, promises];\n  }\n\n  /** @internal */\n  private async getVernacular(uri: string): Promise<vernacularNames> {\n    const result: vernacularNames = new Map();\n    const query =\n      `SELECT DISTINCT ?n WHERE { <${uri}> <http://rs.tdwg.org/dwc/terms/vernacularName> ?n . }`;\n    const bindings = (await this.sparqlEndpoint.getSparqlResultSet(query, {\n      signal: this.controller.signal,\n    }, `Vernacular ${uri}`)).results.bindings;\n    for (const b of bindings) {\n      if (b.n?.value) {\n        if (b.n[\"xml:lang\"]) {\n          if (result.has(b.n[\"xml:lang\"])) {\n            result.get(b.n[\"xml:lang\"])!.push(b.n.value);\n          } else result.set(b.n[\"xml:lang\"], [b.n.value]);\n        } else {\n          if (result.has(\"??\")) result.get(\"??\")!.push(b.n.value);\n          else result.set(\"??\", [b.n.value]);\n        }\n      }\n    }\n    return result;\n  }\n\n  /** @internal\n   *\n   * the supplied \"urls\" must be of the form \"URL>DATE\"\n   */\n  private makeTreatmentSet(urls?: string[]): Set<Treatment> {\n    if (!urls) return new Set<Treatment>();\n    return new Set<Treatment>(\n      urls.filter((url) => !!url).map((url_d) => {\n        const [url, date] = url_d.split(\">\");\n        if (!this.treatments.has(url)) {\n          const details = this.getTreatmentDetails(url);\n          this.treatments.set(url, {\n            url,\n            date: date ? parseInt(date, 10) : undefined,\n            details,\n          });\n        }\n        return this.treatments.get(url) as Treatment;\n      }),\n    );\n  }\n\n  /** @internal */\n  private async getTreatmentDetails(\n    treatmentUri: string,\n  ): Promise<TreatmentDetails> {\n    const query = `\nPREFIX dc: <http://purl.org/dc/elements/1.1/>\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nPREFIX dwcFP: <http://filteredpush.org/ontologies/oa/dwcFP#>\nPREFIX cito: <http://purl.org/spar/cito/>\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT\n  ?date ?title ?mc\n  (group_concat(DISTINCT ?catalogNumber;separator=\" / \") as ?catalogNumbers)\n  (group_concat(DISTINCT ?collectionCode;separator=\" / \") as ?collectionCodes)\n  (group_concat(DISTINCT ?typeStatus;separator=\" / \") as ?typeStatuss)\n  (group_concat(DISTINCT ?countryCode;separator=\" / \") as ?countryCodes)\n  (group_concat(DISTINCT ?stateProvince;separator=\" / \") as ?stateProvinces)\n  (group_concat(DISTINCT ?municipality;separator=\" / \") as ?municipalitys)\n  (group_concat(DISTINCT ?county;separator=\" / \") as ?countys)\n  (group_concat(DISTINCT ?locality;separator=\" / \") as ?localitys)\n  (group_concat(DISTINCT ?verbatimLocality;separator=\" / \") as ?verbatimLocalitys)\n  (group_concat(DISTINCT ?recordedBy;separator=\" / \") as ?recordedBys)\n  (group_concat(DISTINCT ?eventDate;separator=\" / \") as ?eventDates)\n  (group_concat(DISTINCT ?samplingProtocol;separator=\" / \") as ?samplingProtocols)\n  (group_concat(DISTINCT ?decimalLatitude;separator=\" / \") as ?decimalLatitudes)\n  (group_concat(DISTINCT ?decimalLongitude;separator=\" / \") as ?decimalLongitudes)\n  (group_concat(DISTINCT ?verbatimElevation;separator=\" / \") as ?verbatimElevations)\n  (group_concat(DISTINCT ?gbifOccurrenceId;separator=\" / \") as ?gbifOccurrenceIds)\n  (group_concat(DISTINCT ?gbifSpecimenId;separator=\" / \") as ?gbifSpecimenIds)\n  (group_concat(DISTINCT ?creator;separator=\"; \") as ?creators)\n  (group_concat(DISTINCT ?httpUri;separator=\"|\") as ?httpUris)\n  (group_concat(DISTINCT ?aug;separator=\"|\") as ?augs)\n  (group_concat(DISTINCT ?def;separator=\"|\") as ?defs)\n  (group_concat(DISTINCT ?dpr;separator=\"|\") as ?dprs)\n  (group_concat(DISTINCT ?cite;separator=\"|\") as ?cites)\n  (group_concat(DISTINCT ?trttn;separator=\"|\") as ?trttns)\n  (group_concat(DISTINCT ?citetn;separator=\"|\") as ?citetns)\nWHERE {\n  BIND (<${treatmentUri}> as ?treatment)\n  ?treatment dc:creator ?creator .\n  OPTIONAL { ?treatment dc:title ?title }\n  OPTIONAL { ?treatment trt:augmentsTaxonConcept ?aug . }\n  OPTIONAL { ?treatment trt:definesTaxonConcept ?def . }\n  OPTIONAL { ?treatment trt:deprecates ?dpr . }\n  OPTIONAL { ?treatment cito:cites ?cite . ?cite a dwcFP:TaxonConcept . }\n  OPTIONAL { ?treatment trt:treatsTaxonName ?trttn . }\n  OPTIONAL { ?treatment trt:citesTaxonName ?citetn . }\n  OPTIONAL {\n    ?treatment dwc:basisOfRecord ?mc .\n    ?mc dwc:catalogNumber ?catalogNumber .\n    OPTIONAL { ?mc dwc:collectionCode ?collectionCode . }\n    OPTIONAL { ?mc dwc:typeStatus ?typeStatus . }\n    OPTIONAL { ?mc dwc:countryCode ?countryCode . }\n    OPTIONAL { ?mc dwc:stateProvince ?stateProvince . }\n    OPTIONAL { ?mc dwc:municipality ?municipality . }\n    OPTIONAL { ?mc dwc:county ?county . }\n    OPTIONAL { ?mc dwc:locality ?locality . }\n    OPTIONAL { ?mc dwc:verbatimLocality ?verbatimLocality . }\n    OPTIONAL { ?mc dwc:recordedBy ?recordedBy . }\n    OPTIONAL { ?mc dwc:eventDate ?eventDate . }\n    OPTIONAL { ?mc dwc:samplingProtocol ?samplingProtocol . }\n    OPTIONAL { ?mc dwc:decimalLatitude ?decimalLatitude . }\n    OPTIONAL { ?mc dwc:decimalLongitude ?decimalLongitude . }\n    OPTIONAL { ?mc dwc:verbatimElevation ?verbatimElevation . }\n    OPTIONAL { ?mc trt:gbifOccurrenceId ?gbifOccurrenceId . }\n    OPTIONAL { ?mc trt:gbifSpecimenId ?gbifSpecimenId . }\n    OPTIONAL { ?mc trt:httpUri ?httpUri . }\n  }\n}\nGROUP BY ?date ?title ?mc`;\n    if (this.controller.signal.aborted) {\n      return {\n        materialCitations: [],\n        figureCitations: [],\n        treats: {\n          def: new Set(),\n          aug: new Set(),\n          dpr: new Set(),\n          citetc: new Set(),\n          treattn: new Set(),\n          citetn: new Set(),\n        },\n      };\n    }\n    try {\n      const json = await this.sparqlEndpoint.getSparqlResultSet(\n        query,\n        { signal: this.controller.signal },\n        `TreatmentDetails ${treatmentUri}`,\n      );\n      const materialCitations: MaterialCitation[] = json.results.bindings\n        .filter((t) => t.mc && t.catalogNumbers?.value)\n        .map((t) => {\n          const httpUri = t.httpUris?.value?.split(\"|\");\n          return {\n            \"catalogNumber\": t.catalogNumbers!.value,\n            \"collectionCode\": t.collectionCodes?.value || undefined,\n            \"typeStatus\": t.typeStatuss?.value || undefined,\n            \"countryCode\": t.countryCodes?.value || undefined,\n            \"stateProvince\": t.stateProvinces?.value || undefined,\n            \"municipality\": t.municipalitys?.value || undefined,\n            \"county\": t.countys?.value || undefined,\n            \"locality\": t.localitys?.value || undefined,\n            \"verbatimLocality\": t.verbatimLocalitys?.value || undefined,\n            \"recordedBy\": t.recordedBys?.value || undefined,\n            \"eventDate\": t.eventDates?.value || undefined,\n            \"samplingProtocol\": t.samplingProtocols?.value || undefined,\n            \"decimalLatitude\": t.decimalLatitudes?.value || undefined,\n            \"decimalLongitude\": t.decimalLongitudes?.value || undefined,\n            \"verbatimElevation\": t.verbatimElevations?.value || undefined,\n            \"gbifOccurrenceId\": t.gbifOccurrenceIds?.value || undefined,\n            \"gbifSpecimenId\": t.gbifSpecimenIds?.value || undefined,\n            httpUri: httpUri?.length ? httpUri : undefined,\n          };\n        });\n      const figureQuery = `\nPREFIX cito: <http://purl.org/spar/cito/>\nPREFIX fabio: <http://purl.org/spar/fabio/>\nPREFIX dc: <http://purl.org/dc/elements/1.1/>\nSELECT DISTINCT ?url ?description WHERE {\n  <${treatmentUri}> cito:cites ?cites .\n  ?cites a fabio:Figure ;\n  fabio:hasRepresentation ?url .\n  OPTIONAL { ?cites dc:description ?description . }\n} `;\n      const figures = (await this.sparqlEndpoint.getSparqlResultSet(\n        figureQuery,\n        { signal: this.controller.signal },\n        `TreatmentDetails/Figures ${treatmentUri}`,\n      )).results.bindings;\n      const figureCitations = figures.filter((f) => f.url?.value).map(\n        (f) => {\n          return { url: f.url!.value, description: f.description?.value };\n        },\n      );\n      return {\n        creators: json.results.bindings[0]?.creators?.value,\n        title: json.results.bindings[0]?.title?.value,\n        materialCitations,\n        figureCitations,\n        treats: {\n          def: new Set(\n            json.results.bindings[0]?.defs?.value\n              ? json.results.bindings[0].defs.value.split(\"|\")\n              : undefined,\n          ),\n          aug: new Set(\n            json.results.bindings[0]?.augs?.value\n              ? json.results.bindings[0].augs.value.split(\"|\")\n              : undefined,\n          ),\n          dpr: new Set(\n            json.results.bindings[0]?.dprs?.value\n              ? json.results.bindings[0].dprs.value.split(\"|\")\n              : undefined,\n          ),\n          citetc: new Set(\n            json.results.bindings[0]?.cites?.value\n              ? json.results.bindings[0].cites.value.split(\"|\")\n              : undefined,\n          ),\n          treattn: new Set(\n            json.results.bindings[0]?.trttns?.value\n              ? json.results.bindings[0].trttns.value.split(\"|\")\n              : undefined,\n          ),\n          citetn: new Set(\n            json.results.bindings[0]?.citetns?.value\n              ? json.results.bindings[0].citetns.value.split(\"|\")\n              : undefined,\n          ),\n        },\n      };\n    } catch (error) {\n      console.warn(\"SPARQL Error: \" + error);\n      return {\n        materialCitations: [],\n        figureCitations: [],\n        treats: {\n          def: new Set(),\n          aug: new Set(),\n          dpr: new Set(),\n          citetc: new Set(),\n          treattn: new Set(),\n          citetn: new Set(),\n        },\n      };\n    }\n  }\n\n  /** Allows iterating over the synonyms while they are found */\n  [Symbol.asyncIterator](): AsyncIterator<Name> {\n    let returnedSoFar = 0;\n    return {\n      next: () =>\n        new Promise<IteratorResult<Name>>(\n          (resolve, reject) => {\n            const callback = () => {\n              if (this.controller.signal.aborted) {\n                reject(new Error(\"SynyonymGroup has been aborted\"));\n              } else if (returnedSoFar < this.names.length) {\n                resolve({ value: this.names[returnedSoFar++] });\n              } else if (this.isFinished) {\n                resolve({ done: true, value: true });\n              } else {\n                const listener = () => {\n                  this.monitor.removeEventListener(\"updated\", listener);\n                  callback();\n                };\n                this.monitor.addEventListener(\"updated\", listener);\n              }\n            };\n            callback();\n          },\n        ),\n    };\n  }\n}\n\n// TODO: CoL taxa without authority -- associate them with the Name directly\n// eg. 5KTTT is \"Quercus robur subsp. robur\" w/o authority\n\n/** The central object.\n *\n * Each `Name` exists because of a taxon-name, taxon-concept or col-taxon in the data.\n * Each `Name` is uniquely determined by its human-readable latin name (for taxa ranking below genus, this is a multi-part name \u2014 binomial or trinomial) and kingdom.\n */\nexport type Name = {\n  /** taxonomic kingdom */\n  // kingdom: string;\n  /** Human-readable name */\n  displayName: string;\n  /** taxonomic rank */\n  rank: string;\n\n  /** vernacular names */\n  vernacularNames: Promise<vernacularNames>;\n\n  // /** Contains the family tree / upper taxons accorindg to CoL / treatmentbank.\n  //  * //TODO */\n  // trees: Promise<{\n  //   col?: Tree;\n  //   tb?: Tree;\n  // }>;\n\n  /** The URI of the respective `dwcFP:TaxonName` if it exists */\n  taxonNameURI?: string;\n\n  /**\n   * The URI of the respective CoL-taxon if it exists\n   *\n   * Not that this is only for CoL-taxa which do not have an authority.\n   */\n  colURI?: string;\n  /** The URI of the corresponding accepted CoL-taxon if it exists.\n   *\n   * Always present if colURI is present, they are the same if it is the accepted CoL-Taxon.\n   *\n   * May be the string \"INVALID COL\" if the colURI is not valid.\n   */\n  acceptedColURI?: string;\n\n  /** All `AuthorizedName`s with this name */\n  authorizedNames: AuthorizedName[];\n\n  /** How this name was found */\n  justification: Justification;\n\n  /** treatments directly associated with .taxonNameUri */\n  treatments: {\n    treats: Set<Treatment>;\n    cite: Set<Treatment>;\n  };\n};\n\n/**\n * A map from language tags (IETF) to an array of vernacular names.\n */\nexport type vernacularNames = Map<string, string[]>;\n\n/** Why a given Name was found (ther migth be other possible justifications) */\nexport type Justification = {\n  searchTerm: true;\n  /** indicates that this is a subTaxon of the parent */\n  subTaxon: boolean;\n} | {\n  searchTerm: false;\n  parent: Name;\n  /** if missing, indicates synonymy according to CoL or subTaxon */\n  treatment?: Treatment;\n};\n\n/**\n * Corresponds to a taxon-concept or a CoL-Taxon\n */\nexport type AuthorizedName = {\n  // TODO: neccesary?\n  /** this may not be neccesary, as `AuthorizedName`s should only appear within a `Name` */\n  // name: Name;\n  /** Human-readable name */\n  displayName: string;\n  /** Human-readable authority */\n  authority: string;\n\n  /** The URI of the respective `dwcFP:TaxonConcept` if it exists */\n  taxonConceptURI?: string;\n\n  /** The URI of the respective CoL-taxon if it exists */\n  colURI?: string;\n  /** The URI of the corresponding accepted CoL-taxon if it exists.\n   *\n   * Always present if colURI is present, they are the same if it is the accepted CoL-Taxon.\n   *\n   * May be the string \"INVALID COL\" if the colURI is not valid.\n   */\n  acceptedColURI?: string;\n\n  // TODO: sensible?\n  // /** these are CoL-taxa linked in the rdf, which differ lexically */\n  // seeAlsoCol: string[];\n\n  /** treatments directly associated with .taxonConceptURI */\n  treatments: {\n    def: Set<Treatment>;\n    aug: Set<Treatment>;\n    dpr: Set<Treatment>;\n    cite: Set<Treatment>;\n  };\n};\n\n/** A plazi-treatment */\nexport type Treatment = {\n  url: string;\n  date?: number;\n\n  /** Details are behind a promise becuase they are loaded with a separate query. */\n  details: Promise<TreatmentDetails>;\n};\n\n/** Details of a treatment */\nexport type TreatmentDetails = {\n  materialCitations: MaterialCitation[];\n  figureCitations: FigureCitation[];\n  creators?: string;\n  title?: string;\n  treats: {\n    def: Set<string>;\n    aug: Set<string>;\n    dpr: Set<string>;\n    citetc: Set<string>;\n    treattn: Set<string>;\n    citetn: Set<string>;\n  };\n};\n\n/** A cited material */\nexport type MaterialCitation = {\n  \"catalogNumber\": string;\n  \"collectionCode\"?: string;\n  \"typeStatus\"?: string;\n  \"countryCode\"?: string;\n  \"stateProvince\"?: string;\n  \"municipality\"?: string;\n  \"county\"?: string;\n  \"locality\"?: string;\n  \"verbatimLocality\"?: string;\n  \"recordedBy\"?: string;\n  \"eventDate\"?: string;\n  \"samplingProtocol\"?: string;\n  \"decimalLatitude\"?: string;\n  \"decimalLongitude\"?: string;\n  \"verbatimElevation\"?: string;\n  \"gbifOccurrenceId\"?: string;\n  \"gbifSpecimenId\"?: string;\n  \"httpUri\"?: string[];\n};\n\n/** A cited figure */\nexport type FigureCitation = {\n  url: string;\n  description?: string;\n};\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/**\n * Returns all distinct elements in the given array, preserving order by first\n * occurrence.\n *\n * @typeParam T The type of the elements in the input array.\n *\n * @param array The array to filter for distinct elements.\n *\n * @returns An array of distinct elements in the input array.\n *\n * @example Basic usage\n * ```ts\n * import { distinct } from \"@std/collections/distinct\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const numbers = [3, 2, 5, 2, 5];\n * const distinctNumbers = distinct(numbers);\n *\n * assertEquals(distinctNumbers, [3, 2, 5]);\n * ```\n */\nexport function distinct<T>(array: Iterable<T>): T[] {\n  const set = new Set(array);\n\n  return Array.from(set);\n}\n", "/// <reference lib=\"dom\" />\nimport {\n  type Name,\n  SparqlEndpoint,\n  SynonymGroup,\n  type Treatment,\n} from \"../mod.ts\";\nimport { distinct } from \"jsr:@std/collections/distinct\";\n\nconst params = new URLSearchParams(document.location.search);\nconst HIDE_COL_ONLY_SYNONYMS = !params.has(\"show_col\");\nconst START_WITH_SUBTAXA = params.has(\"subtaxa\");\nconst SORT_TREATMENTS_BY_TYPE = params.has(\"sort_treatments_by_type\");\nconst ENDPOINT_URL = params.get(\"server\") ||\n  \"https://treatment.ld.plazi.org/sparql\";\nconst NAME = params.get(\"q\") ||\n  \"https://www.catalogueoflife.org/data/taxon/3WD9M\";\n\nconst root = document.getElementById(\"root\") as HTMLDivElement;\n\nenum SynoStatus {\n  Def = \"def\",\n  Aug = \"aug\",\n  Dpr = \"dpr\",\n  Cite = \"cite\",\n  Full = \"full\",\n}\n\nconst icons = {\n  def:\n    `<svg class=\"green\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"M17,13H13V17H11V13H7V11H11V7H13V11H17M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z\"/></svg>`,\n  aug:\n    `<svg class=\"blue\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z\"/></svg>`,\n  dpr:\n    `<svg class=\"red\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z\"/></svg>`,\n  cite:\n    `<svg class=\"gray\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z\"/></svg>`,\n  unknown:\n    `<svg class=\"gray\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z\"/></svg>`,\n\n  link:\n    `<svg class=\"gray\" viewBox=\"0 0 24 24\"><path fill=\"currentColor\" d=\"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z\"/></svg>`,\n  east:\n    `<svg class=\"gray\" viewBox=\"0 0 24 24\"><path fill=\"currentColor\" d=\"M15,5l-1.41,1.41L18.17,11H2V13h16.17l-4.59,4.59L15,19l7-7L15,5z\"/></svg>`,\n  west:\n    `<svg class=\"gray\" viewBox=\"0 0 24 24\"><path fill=\"currentColor\" d=\"M9,19l1.41-1.41L5.83,13H22V11H5.83l4.59-4.59L9,5l-7,7L9,19z\"/></svg>`,\n  line:\n    `<svg class=\"gray\" viewBox=\"0 0 24 24\"><rect fill=\"currentColor\" height=\"2\" width=\"16\" x=\"4\" y=\"11\"/></svg>`,\n  empty: `<svg viewBox=\"0 0 24 24\"></svg>`,\n};\n\nclass SynoTreatment extends HTMLElement {\n  constructor(trt: Treatment, status: SynoStatus) {\n    super();\n\n    if (status === SynoStatus.Full) this.classList.add(\"expanded\");\n    else {\n      this.innerHTML = icons[status] ?? icons.unknown;\n      this.addEventListener(\"click\", () => {\n        // const expanded = new SynoTreatment(trt, SynoStatus.Full);\n        // this.prepend(expanded);\n        // expanded.addEventListener(\"click\", () => expanded.remove());\n        this.classList.toggle(\"expanded\");\n      });\n    }\n\n    const date = document.createElement(\"span\");\n    if (trt.date) date.innerText = \"\" + trt.date;\n    else {\n      date.classList.add(\"missing\");\n      date.innerText = \"No Date\";\n    }\n    this.append(date);\n\n    const spinner = document.createElement(\"progress\");\n    this.append(\": \", spinner);\n\n    const url = document.createElement(\"a\");\n    url.classList.add(\"treatment\", \"uri\");\n    url.href = trt.url;\n    url.target = \"_blank\";\n    url.innerText = trt.url.replace(\"http://treatment.plazi.org/id/\", \"\");\n    url.innerHTML += icons.link;\n    this.append(\" \", url);\n\n    const names = document.createElement(\"div\");\n    names.classList.add(\"indent\", \"details\");\n    this.append(names);\n\n    trt.details.then((details) => {\n      const creators = document.createElement(\"span\");\n      const title = document.createElement(\"i\");\n      spinner.replaceWith(creators, \" \", title);\n\n      if (details.creators) creators.innerText = details.creators;\n      else {\n        creators.classList.add(\"missing\");\n        creators.innerText = \"No Authors\";\n      }\n\n      if (details.title) title.innerText = \"\u201C\" + details.title + \"\u201D\";\n      else {\n        title.classList.add(\"missing\");\n        title.innerText = \"No Title\";\n      }\n\n      if (details.treats.def.size > 0) {\n        const line = document.createElement(\"div\");\n        // line.innerHTML = status === SynoStatus.Cite ? icons.line : icons.east;\n        line.innerHTML = icons.east;\n        line.innerHTML += icons.def;\n        if (status === SynoStatus.Def || status === SynoStatus.Cite) {\n          line.classList.add(\"hidden\");\n        }\n        names.append(line);\n\n        details.treats.def.forEach((n) => {\n          const url = document.createElement(\"a\");\n          url.classList.add(\"taxon\", \"uri\");\n          const short = n.replace(\"http://taxon-concept.plazi.org/id/\", \"\");\n          url.innerText = short;\n          url.href = \"#\" + short;\n          url.title = \"show name\";\n          line.append(url);\n        });\n      }\n      if (details.treats.aug.size > 0 || details.treats.treattn.size > 0) {\n        const line = document.createElement(\"div\");\n        // line.innerHTML = status === SynoStatus.Cite ? icons.line : icons.east;\n        line.innerHTML = icons.east;\n        line.innerHTML += icons.aug;\n        if (status === SynoStatus.Aug || status === SynoStatus.Cite) {\n          line.classList.add(\"hidden\");\n        }\n        names.append(line);\n\n        details.treats.aug.forEach((n) => {\n          const url = document.createElement(\"a\");\n          url.classList.add(\"taxon\", \"uri\");\n          const short = n.replace(\"http://taxon-concept.plazi.org/id/\", \"\");\n          url.innerText = short;\n          url.href = \"#\" + short;\n          url.title = \"show name\";\n          line.append(url);\n        });\n        details.treats.treattn.forEach((n) => {\n          const url = document.createElement(\"a\");\n          url.classList.add(\"taxon\", \"uri\");\n          const short = n.replace(\"http://taxon-name.plazi.org/id/\", \"\");\n          url.innerText = short;\n          url.href = \"#\" + short;\n          url.title = \"show name\";\n          line.append(url);\n        });\n      }\n      if (details.treats.dpr.size > 0) {\n        const line = document.createElement(\"div\");\n        // line.innerHTML = status === SynoStatus.Cite ? icons.line : icons.west;\n        line.innerHTML = icons.west;\n        line.innerHTML += icons.dpr;\n        if (status === SynoStatus.Dpr || status === SynoStatus.Cite) {\n          line.classList.add(\"hidden\");\n        }\n        names.append(line);\n\n        details.treats.dpr.forEach((n) => {\n          const url = document.createElement(\"a\");\n          url.classList.add(\"taxon\", \"uri\");\n          const short = n.replace(\"http://taxon-concept.plazi.org/id/\", \"\");\n          url.innerText = short;\n          url.href = \"#\" + short;\n          url.title = \"show name\";\n          line.append(url);\n        });\n      }\n      if (details.treats.citetc.size > 0 || details.treats.citetn.size > 0) {\n        const line = document.createElement(\"div\");\n        line.innerHTML = icons.empty + icons.cite;\n        // if (status === SynoStatus.Dpr || status === SynoStatus.Cite) {\n        line.classList.add(\"hidden\");\n        // }\n        names.append(line);\n\n        details.treats.citetc.forEach((n) => {\n          const url = document.createElement(\"a\");\n          url.classList.add(\"taxon\", \"uri\");\n          const short = n.replace(\"http://taxon-concept.plazi.org/id/\", \"\");\n          url.innerText = short;\n          url.href = \"#\" + short;\n          url.title = \"show name\";\n          line.append(url);\n        });\n        details.treats.citetn.forEach((n) => {\n          const url = document.createElement(\"a\");\n          url.classList.add(\"taxon\", \"uri\");\n          const short = n.replace(\"http://taxon-name.plazi.org/id/\", \"\");\n          url.innerText = short;\n          url.href = \"#\" + short;\n          url.title = \"show name\";\n          line.append(url);\n        });\n      }\n    });\n  }\n}\ncustomElements.define(\"syno-treatment\", SynoTreatment);\n\nclass SynoName extends HTMLElement {\n  constructor(name: Name) {\n    super();\n\n    const title = document.createElement(\"h2\");\n    const name_title = document.createElement(\"i\");\n    name_title.innerText = name.displayName;\n    title.append(name_title);\n    this.append(title);\n\n    const rank_badge = document.createElement(\"span\");\n    rank_badge.classList.add(\"rank\");\n    rank_badge.innerText = name.rank;\n    title.append(\" \", rank_badge);\n\n    if (name.taxonNameURI) {\n      const name_uri = document.createElement(\"a\");\n      name_uri.classList.add(\"taxon\", \"uri\");\n      const short = name.taxonNameURI.replace(\n        \"http://taxon-name.plazi.org/id/\",\n        \"\",\n      );\n      name_uri.innerText = short;\n      name_uri.id = short;\n      name_uri.href = name.taxonNameURI;\n      name_uri.target = \"_blank\";\n      name_uri.innerHTML += icons.link;\n      title.append(\" \", name_uri);\n    }\n\n    const vernacular = document.createElement(\"div\");\n    vernacular.classList.add(\"vernacular\");\n    name.vernacularNames.then((names) => {\n      if (names.size > 0) {\n        vernacular.innerText = \"\u201C\" +\n          distinct([...names.values()].flat()).join(\"\u201D, \u201C\") + \"\u201D\";\n      }\n    });\n    this.append(vernacular);\n\n    const treatments = document.createElement(\"ul\");\n    this.append(treatments);\n\n    if (name.colURI) {\n      const col_uri = document.createElement(\"a\");\n      col_uri.classList.add(\"col\", \"uri\");\n      const id = name.colURI.replace(\n        \"https://www.catalogueoflife.org/data/taxon/\",\n        \"\",\n      );\n      col_uri.innerText = id;\n      col_uri.id = id;\n      col_uri.href = name.colURI;\n      col_uri.target = \"_blank\";\n      col_uri.innerHTML += icons.link;\n      title.append(\" \", col_uri);\n\n      const li = document.createElement(\"div\");\n      li.classList.add(\"treatmentline\");\n      li.innerHTML = name.acceptedColURI !== name.colURI\n        ? icons.dpr\n        : icons.aug;\n      treatments.append(li);\n\n      const creators = document.createElement(\"span\");\n      creators.innerText = \"Catalogue of Life\";\n      li.append(creators);\n\n      const names = document.createElement(\"div\");\n      names.classList.add(\"indent\");\n      li.append(names);\n\n      if (name.acceptedColURI !== name.colURI) {\n        const line = document.createElement(\"div\");\n        line.innerHTML = icons.east + icons.aug;\n        names.append(line);\n\n        const col_uri = document.createElement(\"a\");\n        col_uri.classList.add(\"col\", \"uri\");\n        const id = name.acceptedColURI!.replace(\n          \"https://www.catalogueoflife.org/data/taxon/\",\n          \"\",\n        );\n        col_uri.innerText = id;\n        col_uri.href = `#${id}`;\n        col_uri.title = \"show name\";\n        line.append(col_uri);\n      }\n    }\n    if (name.treatments.treats.size > 0 || name.treatments.cite.size > 0) {\n      for (const trt of name.treatments.treats) {\n        const li = new SynoTreatment(trt, SynoStatus.Aug);\n        treatments.append(li);\n      }\n      for (const trt of name.treatments.cite) {\n        const li = new SynoTreatment(trt, SynoStatus.Cite);\n        treatments.append(li);\n      }\n    }\n\n    const justification = document.createElement(\"abbr\");\n    justification.classList.add(\"justification\");\n    justification.innerText = \"...?\";\n    justify(name).then((just) => justification.title = `This ${just}`);\n    title.append(\" \", justification);\n\n    for (const authorizedName of name.authorizedNames) {\n      const authName = document.createElement(\"h3\");\n      const name_title = document.createElement(\"i\");\n      name_title.innerText = authorizedName.displayName;\n      name_title.classList.add(\"gray\");\n      authName.append(name_title);\n      authName.append(\" \", authorizedName.authority);\n      this.append(authName);\n\n      const treatments = document.createElement(\"ul\");\n      this.append(treatments);\n\n      if (authorizedName.taxonConceptURI) {\n        const name_uri = document.createElement(\"a\");\n        name_uri.classList.add(\"taxon\", \"uri\");\n        const short = authorizedName.taxonConceptURI.replace(\n          \"http://taxon-concept.plazi.org/id/\",\n          \"\",\n        );\n        name_uri.innerText = short;\n        name_uri.id = short;\n        name_uri.href = authorizedName.taxonConceptURI;\n        name_uri.target = \"_blank\";\n        name_uri.innerHTML += icons.link;\n        authName.append(\" \", name_uri);\n      }\n      if (authorizedName.colURI) {\n        const col_uri = document.createElement(\"a\");\n        col_uri.classList.add(\"col\", \"uri\");\n        const id = authorizedName.colURI.replace(\n          \"https://www.catalogueoflife.org/data/taxon/\",\n          \"\",\n        );\n        col_uri.innerText = id;\n        col_uri.id = id;\n        col_uri.href = authorizedName.colURI;\n        col_uri.target = \"_blank\";\n        col_uri.innerHTML += icons.link;\n        authName.append(\" \", col_uri);\n\n        const li = document.createElement(\"div\");\n        li.classList.add(\"treatmentline\");\n        li.innerHTML = authorizedName.acceptedColURI !== authorizedName.colURI\n          ? icons.dpr\n          : icons.aug;\n        treatments.append(li);\n\n        const creators = document.createElement(\"span\");\n        creators.innerText = \"Catalogue of Life\";\n        li.append(creators);\n\n        const names = document.createElement(\"div\");\n        names.classList.add(\"indent\");\n        li.append(names);\n\n        if (authorizedName.acceptedColURI !== authorizedName.colURI) {\n          const line = document.createElement(\"div\");\n          line.innerHTML = icons.east + icons.aug;\n          names.append(line);\n\n          const col_uri = document.createElement(\"a\");\n          col_uri.classList.add(\"col\", \"uri\");\n          const id = authorizedName.acceptedColURI!.replace(\n            \"https://www.catalogueoflife.org/data/taxon/\",\n            \"\",\n          );\n          col_uri.innerText = id;\n          col_uri.href = `#${id}`;\n          col_uri.title = \"show name\";\n          line.append(col_uri);\n        }\n      }\n\n      const treatments_array: { trt: Treatment; status: SynoStatus }[] = [];\n\n      for (const trt of authorizedName.treatments.def) {\n        treatments_array.push({ trt, status: SynoStatus.Def });\n      }\n      for (const trt of authorizedName.treatments.aug) {\n        treatments_array.push({ trt, status: SynoStatus.Aug });\n      }\n      for (const trt of authorizedName.treatments.dpr) {\n        treatments_array.push({ trt, status: SynoStatus.Dpr });\n      }\n      for (const trt of authorizedName.treatments.cite) {\n        treatments_array.push({ trt, status: SynoStatus.Cite });\n      }\n\n      if (!SORT_TREATMENTS_BY_TYPE) {\n        treatments_array.sort((a, b) => {\n          if (a.trt.date && b.trt.date) return a.trt.date - b.trt.date;\n          if (a.trt.date) return 1;\n          if (b.trt.date) return -1;\n          return 0;\n        });\n      }\n\n      for (const { trt, status } of treatments_array) {\n        const li = new SynoTreatment(trt, status);\n        treatments.append(li);\n      }\n    }\n  }\n}\ncustomElements.define(\"syno-name\", SynoName);\n\nasync function justify(name: Name): Promise<string> {\n  if (name.justification.searchTerm) {\n    if (name.justification.subTaxon) {\n      return \"is a sub-taxon of the search term.\";\n    } else return \"is the search term.\";\n  } else if (name.justification.treatment) {\n    const details = await name.justification.treatment.details;\n    const parent = await justify(name.justification.parent);\n    return `is, according to ${details.creators} ${name.justification.treatment.date},\\n     a synonym of ${name.justification.parent.displayName} which ${parent}`;\n    // return `is, according to ${details.creators} ${details.date} \u201C${details.title||\"No Title\"}\u201D ${name.justification.treatment.url},\\n     a synonym of ${name.justification.parent.displayName} which ${parent}`;\n  } else {\n    const parent = await justify(name.justification.parent);\n    return `is, according to the Catalogue of Life,\\n     a synonym of ${name.justification.parent.displayName} which ${parent}`;\n  }\n}\n\nconst indicator = document.createElement(\"div\");\nroot.insertAdjacentElement(\"beforebegin\", indicator);\nindicator.append(`Finding Synonyms for ${NAME} `);\nconst progress = document.createElement(\"progress\");\nindicator.append(progress);\n\nconst timeStart = performance.now();\n\nconst sparqlEndpoint = new SparqlEndpoint(ENDPOINT_URL);\nconst synoGroup = new SynonymGroup(\n  sparqlEndpoint,\n  NAME,\n  HIDE_COL_ONLY_SYNONYMS,\n  START_WITH_SUBTAXA,\n);\n\nfor await (const name of synoGroup) {\n  const element = new SynoName(name);\n  root.append(element);\n}\n\nconst timeEnd = performance.now();\n\nindicator.innerHTML = \"\";\nindicator.innerText =\n  `Found ${synoGroup.names.length} names with ${synoGroup.treatments.size} treatments. This took ${\n    (timeEnd - timeStart) / 1000\n  } seconds.`;\nif (synoGroup.names.length === 0) root.append(\":[\");\n"],
  "mappings": "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",
  "names": ["sleep", "ms", "resolve", "SparqlEndpoint", "sparqlEnpointUri", "query", "fetchOptions", "_reason", "retryCount", "sendRequest", "response", "error", "wait", "SynonymGroup", "name", "sparqlEndpoint", "taxonName", "ignoreDeprecatedCoL", "startWithSubTaxa", "e", "n", "justification", "url", "query", "names", "genus", "species", "infrasp", "colUri", "json", "tcUri", "tnUri", "treatmentPromises", "displayName", "unathorizedCol", "authorizedCoLNames", "authorizedTCNames", "taxonNameURI", "t", "colURI", "def", "aug", "dpr", "cite", "colName", "treats", "authName", "colPromises", "acceptedColURI", "promises", "newSynonyms", "treat", "d", "s", "treatment", "parent", "b", "uri", "result", "bindings", "urls", "url_d", "date", "details", "treatmentUri", "materialCitations", "httpUri", "figureQuery", "figureCitations", "f", "error", "returnedSoFar", "resolve", "reject", "callback", "listener", "distinct", "array", "set", "params", "HIDE_COL_ONLY_SYNONYMS", "START_WITH_SUBTAXA", "SORT_TREATMENTS_BY_TYPE", "ENDPOINT_URL", "NAME", "root", "icons", "SynoTreatment", "trt", "status", "date", "spinner", "url", "names", "details", "creators", "title", "line", "n", "short", "SynoName", "name", "name_title", "rank_badge", "name_uri", "vernacular", "distinct", "treatments", "col_uri", "id", "li", "justification", "justify", "just", "authorizedName", "authName", "treatments_array", "SORT_TREATMENTS_BY_TYPE", "a", "b", "parent", "indicator", "root", "NAME", "progress", "timeStart", "sparqlEndpoint", "SparqlEndpoint", "ENDPOINT_URL", "synoGroup", "SynonymGroup", "HIDE_COL_ONLY_SYNONYMS", "START_WITH_SUBTAXA", "element", "timeEnd"]
}

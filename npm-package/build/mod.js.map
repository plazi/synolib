{
  "version": 3,
  "sources": ["../../SparqlEndpoint.ts", "../../SynonymGroup.ts"],
  "sourcesContent": ["async function sleep(ms: number): Promise<void> {\n  const p = new Promise<void>((resolve) => {\n    setTimeout(resolve, ms);\n  });\n  return await p;\n}\n\n/** Describes the format of the JSON return by SPARQL endpoints */\nexport type SparqlJson = {\n  head: {\n    vars: string[];\n  };\n  results: {\n    bindings: {\n      [key: string]:\n        | { type: string; value: string; \"xml:lang\"?: string }\n        | undefined;\n    }[];\n  };\n};\n\n/**\n * Represents a remote sparql endpoint and provides a uniform way to run queries.\n */\nexport class SparqlEndpoint {\n  /** Create a new SparqlEndpoint with the given URI */\n  constructor(private sparqlEnpointUri: string) {}\n\n  /** @ignore */\n  // reasons: string[] = [];\n\n  /**\n   * Run a query against the sparql endpoint\n   *\n   * It automatically retries up to 10 times on fetch errors, waiting 50ms on the first retry and doupling the wait each time.\n   * Retries are logged to the console (`console.warn`)\n   *\n   * @throws In case of non-ok response status codes or if fetch failed 10 times.\n   * @param query The sparql query to run against the endpoint\n   * @param fetchOptions Additional options for the `fetch` request\n   * @param _reason (Currently ignored, used internally for debugging purposes)\n   * @returns Results of the query\n   */\n  async getSparqlResultSet(\n    query: string,\n    fetchOptions: RequestInit = {},\n    _reason = \"\",\n  ): Promise<SparqlJson> {\n    // this.reasons.push(_reason);\n\n    fetchOptions.headers = fetchOptions.headers || {};\n    (fetchOptions.headers as Record<string, string>)[\"Accept\"] =\n      \"application/sparql-results+json\";\n    let retryCount = 0;\n    const sendRequest = async (): Promise<SparqlJson> => {\n      try {\n        // console.info(`SPARQL ${_reason} (${retryCount + 1})`);\n        const response = await fetch(\n          this.sparqlEnpointUri + \"?query=\" + encodeURIComponent(query),\n          fetchOptions,\n        );\n        if (!response.ok) {\n          throw new Error(\"Response not ok. Status \" + response.status);\n        }\n        return await response.json();\n      } catch (error) {\n        if (fetchOptions.signal?.aborted) {\n          throw error;\n        } else if (retryCount < 10) {\n          const wait = 50 * (1 << retryCount++);\n          console.warn(`!! Fetch Error. Retrying in ${wait}ms (${retryCount})`);\n          await sleep(wait);\n          return await sendRequest();\n        }\n        console.warn(\"!! Fetch Error:\", query, \"\\n---\\n\", error);\n        throw error;\n      }\n    };\n    return await sendRequest();\n  }\n}\n", "import { SparqlEndpoint, SparqlJson } from \"./mod.ts\";\n\n/** Finds all synonyms of a taxon */\nexport class SynonymGroup implements AsyncIterable<Name> {\n  /** Indicates whether the SynonymGroup has found all synonyms.\n   *\n   * @readonly\n   */\n  isFinished = false;\n  /** Used internally to watch for new names found */\n  private monitor = new EventTarget();\n\n  /** Used internally to abort in-flight network requests when SynonymGroup is aborted */\n  private controller = new AbortController();\n\n  /** The SparqlEndpoint used */\n  private sparqlEndpoint: SparqlEndpoint;\n\n  /**\n   * List of names found so-far.\n   *\n   * Contains full list of synonyms _if_ .isFinished and not .isAborted\n   *\n   * @readonly\n   */\n  names: Name[] = [];\n  /**\n   * Add a new Name to this.names.\n   *\n   * Note: does not deduplicate on its own\n   *\n   * @internal */\n  private pushName(name: Name) {\n    this.names.push(name);\n    this.monitor.dispatchEvent(new CustomEvent(\"updated\"));\n  }\n\n  /**\n   * Call when all synonyms are found\n   *\n   * @internal */\n  private finish() {\n    this.isFinished = true;\n    this.monitor.dispatchEvent(new CustomEvent(\"updated\"));\n  }\n\n  /** contains TN, TC, CoL uris of synonyms which are in-flight somehow or are done already */\n  private expanded = new Set<string>(); // new Map<string, NameStatus>();\n\n  /** contains CoL uris where we don't need to check for Col \"acceptedName\" links\n   *\n   * col -> accepted col\n   */\n  private acceptedCol = new Map<string, string>();\n\n  /**\n   * Used internally to deduplicate treatments, maps from URI to Object.\n   *\n   * Contains full list of treatments _if_ .isFinished and not .isAborted\n   *\n   * @readonly\n   */\n  treatments = new Map<string, Treatment>();\n\n  /**\n   * Whether to show taxa deprecated by CoL that would not have been found otherwise.\n   * This significantly increases the number of results in some cases.\n   */\n  ignoreDeprecatedCoL: boolean;\n\n  /**\n   * if set to true, subTaxa of the search term are also considered as starting points.\n   *\n   * Not that \"weird\" ranks like subGenus are always included when searching for a genus by latin name.\n   */\n  startWithSubTaxa: boolean;\n\n  /**\n   * Constructs a SynonymGroup\n   *\n   * @param sparqlEndpoint SPARQL-Endpoint to query\n   * @param taxonName either a string of the form \"Genus species infraspecific\" (species & infraspecific names optional), or an URI of a http://filteredpush.org/ontologies/oa/dwcFP#TaxonConcept or ...#TaxonName or a CoL taxon URI\n   * @param [ignoreDeprecatedCoL=true] Whether to show taxa deprecated by CoL that would not have been found otherwise\n   * @param [startWithSubTaxa=false] if set to true, subTaxa of the search term are also considered as starting points.\n   */\n  constructor(\n    sparqlEndpoint: SparqlEndpoint,\n    taxonName: string,\n    ignoreDeprecatedCoL = true,\n    startWithSubTaxa = false,\n  ) {\n    this.sparqlEndpoint = sparqlEndpoint;\n    this.ignoreDeprecatedCoL = ignoreDeprecatedCoL;\n    this.startWithSubTaxa = startWithSubTaxa;\n\n    if (taxonName.startsWith(\"http\")) {\n      this.getName(taxonName, { searchTerm: true, subTaxon: false }).finally(\n        () => this.finish(),\n      );\n    } else {\n      const name = [\n        ...taxonName.split(\" \").filter((n) => !!n),\n        undefined,\n        undefined,\n      ] as [string, string | undefined, string | undefined];\n      this.getNameFromLatin(name, { searchTerm: true, subTaxon: false })\n        .finally(\n          () => this.finish(),\n        );\n    }\n  }\n\n  /** @internal */\n  private async getName(\n    taxonName: string,\n    justification: Justification,\n  ): Promise<void> {\n    if (this.expanded.has(taxonName)) {\n      console.log(\"Skipping known\", taxonName);\n      return;\n    }\n\n    if (taxonName.startsWith(\"https://www.catalogueoflife.org\")) {\n      await this.getNameFromCol(taxonName, justification);\n    } else if (taxonName.startsWith(\"http://taxon-concept.plazi.org\")) {\n      await this.getNameFromTC(taxonName, justification);\n    } else if (taxonName.startsWith(\"http://taxon-name.plazi.org\")) {\n      await this.getNameFromTN(taxonName, justification);\n    } else {\n      throw `Cannot handle name-uri <${taxonName}> !`;\n    }\n\n    if (\n      this.startWithSubTaxa && justification.searchTerm &&\n      !justification.subTaxon\n    ) {\n      await this.getSubtaxa(taxonName);\n    }\n  }\n\n  /** @internal */\n  private async getSubtaxa(url: string): Promise<void> {\n    const query = url.startsWith(\"http://taxon-concept.plazi.org\")\n      ? `\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT ?sub WHERE {\n  BIND(<${url}> as ?url)\n  ?sub trt:hasParentName*/^trt:hasTaxonName ?url .\n}\nLIMIT 5000`\n      : `\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT ?sub WHERE {\n  BIND(<${url}> as ?url)\n  ?sub (dwc:parent|trt:hasParentName)* ?url .\n}\nLIMIT 5000`;\n\n    if (this.controller.signal?.aborted) return Promise.reject();\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `Subtaxa ${url}`,\n    );\n\n    const names = json.results.bindings\n      .map((n) => n.sub?.value)\n      .filter((n) => n && !this.expanded.has(n)) as string[];\n\n    await Promise.allSettled(\n      names.map((n) => this.getName(n, { searchTerm: true, subTaxon: true })),\n    );\n  }\n\n  /** @internal */\n  private async getNameFromLatin(\n    [genus, species, infrasp]: [string, string | undefined, string | undefined],\n    justification: Justification,\n  ): Promise<void> {\n    const query = `\n    PREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nSELECT DISTINCT ?uri WHERE {\n  ?uri dwc:genus|dwc:genericName \"${genus}\" .\n  ${\n      species\n        ? `?uri dwc:species|dwc:specificEpithet \"${species}\" .`\n        : \"FILTER NOT EXISTS { ?uri dwc:species|dwc:specificEpithet ?species . }\"\n    }\n  ${\n      infrasp\n        ? `?uri dwc:subspecies|dwc:variety|dwc:infraspecificEpithet \"${infrasp}\" .`\n        : \"FILTER NOT EXISTS { ?uri dwc:subspecies|dwc:variety|dwc:infraspecificEpithet ?infrasp . }\"\n    }\n}\nLIMIT 500`;\n\n    if (this.controller.signal?.aborted) return Promise.reject();\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `NameFromLatin ${genus} ${species} ${infrasp}`,\n    );\n\n    const names = json.results.bindings\n      .map((n) => n.uri?.value)\n      .filter((n) => n && !this.expanded.has(n)) as string[];\n\n    await Promise.allSettled(names.map((n) => this.getName(n, justification)));\n  }\n\n  /** @internal */\n  private async getNameFromCol(\n    colUri: string,\n    justification: Justification,\n  ): Promise<void> {\n    // Note: this query assumes that there is no sub-species taxa with missing dwc:species\n    // Note: the handling assumes that at most one taxon-name matches this colTaxon\n    const query = `\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nPREFIX dwcFP: <http://filteredpush.org/ontologies/oa/dwcFP#>\nPREFIX cito: <http://purl.org/spar/cito/>\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\n  (group_concat(DISTINCT ?tcauth;separator=\" / \") AS ?tcAuth)\n  (group_concat(DISTINCT ?aug;separator=\"|\") as ?augs)\n  (group_concat(DISTINCT ?def;separator=\"|\") as ?defs)\n  (group_concat(DISTINCT ?dpr;separator=\"|\") as ?dprs)\n  (group_concat(DISTINCT ?cite;separator=\"|\") as ?cites)\n  (group_concat(DISTINCT ?trtn;separator=\"|\") as ?tntreats)\n  (group_concat(DISTINCT ?citetn;separator=\"|\") as ?tncites) WHERE {\n  BIND(<${colUri}> as ?col)\n  ?col dwc:taxonRank ?rank .\n  OPTIONAL { ?col dwc:scientificNameAuthorship ?colAuth . } BIND(COALESCE(?colAuth, \"\") as ?authority)\n  ?col dwc:scientificName ?name . # Note: contains authority\n  ?col dwc:genericName ?genus .\n  # TODO # ?col dwc:parent* ?p . ?p dwc:rank \"kingdom\" ; dwc:taxonName ?kingdom .\n  OPTIONAL {\n    ?col dwc:specificEpithet ?species .\n    OPTIONAL { ?col dwc:infraspecificEpithet ?infrasp . }\n  }\n\n  OPTIONAL {\n    ?tn a dwcFP:TaxonName .\n    ?tn dwc:rank ?rank .\n    ?tn dwc:genus ?genus .\n    ?tn dwc:kingdom ?kingdom .\n    {\n      ?col dwc:specificEpithet ?species .\n      ?tn dwc:species ?species .\n      {\n        ?col dwc:infraspecificEpithet ?infrasp .\n        ?tn dwc:subspecies|dwc:variety ?infrasp .\n      } UNION {\n        FILTER NOT EXISTS { ?col dwc:infraspecificEpithet ?infrasp . }\n        FILTER NOT EXISTS { ?tn dwc:subspecies|dwc:variety ?infrasp . }\n      }\n    } UNION {\n      FILTER NOT EXISTS { ?col dwc:specificEpithet ?species . }\n      FILTER NOT EXISTS { ?tn dwc:species ?species . }\n    }\n\n    OPTIONAL { ?trtn trt:treatsTaxonName ?tn . }\n    OPTIONAL { ?citetn trt:citesTaxonName ?tn . }\n\n    OPTIONAL {\n      ?tc trt:hasTaxonName ?tn ;\n          dwc:scientificNameAuthorship ?tcauth ;\n          a dwcFP:TaxonConcept .\n      OPTIONAL { ?aug trt:augmentsTaxonConcept ?tc . }\n      OPTIONAL { ?def trt:definesTaxonConcept ?tc . }\n      OPTIONAL { ?dpr trt:deprecates ?tc . }\n      OPTIONAL { ?cite cito:cites ?tc . }\n    }\n  }\n}\nGROUP BY ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\nLIMIT 500`;\n    // For unclear reasons, the query breaks if the limit is removed.\n\n    if (this.controller.signal?.aborted) return Promise.reject();\n\n    /// ?tn ?tc !rank !genus ?species ?infrasp !name !authority ?tcAuth\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `NameFromCol ${colUri}`,\n    );\n\n    return this.handleName(json, justification);\n  }\n\n  /** @internal */\n  private async getNameFromTC(\n    tcUri: string,\n    justification: Justification,\n  ): Promise<void> {\n    // Note: this query assumes that there is no sub-species taxa with missing dwc:species\n    // Note: the handling assumes that at most one taxon-name matches this colTaxon\n    const query = `\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nPREFIX dwcFP: <http://filteredpush.org/ontologies/oa/dwcFP#>\nPREFIX cito: <http://purl.org/spar/cito/>\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\n  (group_concat(DISTINCT ?tcauth;separator=\" / \") AS ?tcAuth)\n  (group_concat(DISTINCT ?aug;separator=\"|\") as ?augs)\n  (group_concat(DISTINCT ?def;separator=\"|\") as ?defs)\n  (group_concat(DISTINCT ?dpr;separator=\"|\") as ?dprs)\n  (group_concat(DISTINCT ?cite;separator=\"|\") as ?cites)\n  (group_concat(DISTINCT ?trtn;separator=\"|\") as ?tntreats)\n  (group_concat(DISTINCT ?citetn;separator=\"|\") as ?tncites) WHERE {\n  <${tcUri}> trt:hasTaxonName ?tn .\n  ?tc trt:hasTaxonName ?tn ;\n      dwc:scientificNameAuthorship ?tcauth ;\n      a dwcFP:TaxonConcept .\n\n  ?tn a dwcFP:TaxonName .\n  ?tn dwc:rank ?rank .\n  ?tn dwc:kingdom ?kingdom .\n  ?tn dwc:genus ?genus .\n  OPTIONAL {\n    ?tn dwc:species ?species .\n    OPTIONAL { ?tn dwc:subspecies|dwc:variety ?infrasp . }\n  }\n  \n  OPTIONAL {\n    ?col dwc:taxonRank ?rank .\n    OPTIONAL { ?col dwc:scientificNameAuthorship ?colAuth . }\n    ?col dwc:scientificName ?fullName . # Note: contains authority\n    ?col dwc:genericName ?genus .\n    # TODO # ?col dwc:parent* ?p . ?p dwc:rank \"kingdom\" ; dwc:taxonName ?kingdom .\n\n    {\n      ?col dwc:specificEpithet ?species .\n      ?tn dwc:species ?species .\n      {\n        ?col dwc:infraspecificEpithet ?infrasp .\n        ?tn dwc:subspecies|dwc:variety ?infrasp .\n      } UNION {\n        FILTER NOT EXISTS { ?col dwc:infraspecificEpithet ?infrasp . }\n        FILTER NOT EXISTS { ?tn dwc:subspecies|dwc:variety ?infrasp . }\n      }\n    } UNION {\n      FILTER NOT EXISTS { ?col dwc:specificEpithet ?species . }\n      FILTER NOT EXISTS { ?tn dwc:species ?species . }\n    }\n  }\n  \n  BIND(COALESCE(?fullName, CONCAT(?genus, COALESCE(CONCAT(\" (\",?subgenus,\")\"), \"\"), COALESCE(CONCAT(\" \",?species), \"\"), COALESCE(CONCAT(\" \", ?infrasp), \"\"))) as ?name)\n  BIND(COALESCE(?colAuth, \"\") as ?authority)\n\n  OPTIONAL { ?trtn trt:treatsTaxonName ?tn . }\n  OPTIONAL { ?citetn trt:citesTaxonName ?tn . }\n\n  OPTIONAL { ?aug trt:augmentsTaxonConcept ?tc . }\n  OPTIONAL { ?def trt:definesTaxonConcept ?tc . }\n  OPTIONAL { ?dpr trt:deprecates ?tc . }\n  OPTIONAL { ?cite cito:cites ?tc . }\n}\nGROUP BY ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\nLIMIT 500`;\n    // For unclear reasons, the query breaks if the limit is removed.\n\n    if (this.controller.signal?.aborted) return Promise.reject();\n\n    /// ?tn ?tc ?col !rank !genus ?species ?infrasp !name !authority ?tcAuth\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `NameFromTC ${tcUri}`,\n    );\n\n    await this.handleName(json, justification);\n  }\n\n  /** @internal */\n  private async getNameFromTN(\n    tnUri: string,\n    justification: Justification,\n  ): Promise<void> {\n    // Note: this query assumes that there is no sub-species taxa with missing dwc:species\n    // Note: the handling assumes that at most one taxon-name matches this colTaxon\n    const query = `\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nPREFIX dwcFP: <http://filteredpush.org/ontologies/oa/dwcFP#>\nPREFIX cito: <http://purl.org/spar/cito/>\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\n  (group_concat(DISTINCT ?tcauth;separator=\" / \") AS ?tcAuth)\n  (group_concat(DISTINCT ?aug;separator=\"|\") as ?augs)\n  (group_concat(DISTINCT ?def;separator=\"|\") as ?defs)\n  (group_concat(DISTINCT ?dpr;separator=\"|\") as ?dprs)\n  (group_concat(DISTINCT ?cite;separator=\"|\") as ?cites)\n  (group_concat(DISTINCT ?trtn;separator=\"|\") as ?tntreats)\n  (group_concat(DISTINCT ?citetn;separator=\"|\") as ?tncites) WHERE {\n  BIND(<${tnUri}> as ?tn)\n  ?tn a dwcFP:TaxonName .\n  ?tn dwc:rank ?rank .\n  ?tn dwc:genus ?genus .\n  ?tn dwc:kingdom ?kingdom .\n  OPTIONAL {\n    ?tn dwc:species ?species .\n    OPTIONAL { ?tn dwc:subspecies|dwc:variety ?infrasp . }\n  }\n  \n  OPTIONAL {\n    ?col dwc:taxonRank ?rank .\n    OPTIONAL { ?col dwc:scientificNameAuthorship ?colAuth . }\n    ?col dwc:scientificName ?fullName . # Note: contains authority\n    ?col dwc:genericName ?genus .\n    # TODO # ?col dwc:parent* ?p . ?p dwc:rank \"kingdom\" ; dwc:taxonName ?kingdom .\n\n    {\n      ?col dwc:specificEpithet ?species .\n      ?tn dwc:species ?species .\n      {\n        ?col dwc:infraspecificEpithet ?infrasp .\n        ?tn dwc:subspecies|dwc:variety ?infrasp .\n      } UNION {\n        FILTER NOT EXISTS { ?col dwc:infraspecificEpithet ?infrasp . }\n        FILTER NOT EXISTS { ?tn dwc:subspecies|dwc:variety ?infrasp . }\n      }\n    } UNION {\n      FILTER NOT EXISTS { ?col dwc:specificEpithet ?species . }\n      FILTER NOT EXISTS { ?tn dwc:species ?species . }\n    }\n  }\n  \n  BIND(COALESCE(?fullName, CONCAT(?genus, COALESCE(CONCAT(\" (\",?subgenus,\")\"), \"\"), COALESCE(CONCAT(\" \",?species), \"\"), COALESCE(CONCAT(\" \", ?infrasp), \"\"))) as ?name)\n  BIND(COALESCE(?colAuth, \"\") as ?authority)\n\n  OPTIONAL { ?trtn trt:treatsTaxonName ?tn . }\n  OPTIONAL { ?citetn trt:citesTaxonName ?tn . }\n\n  OPTIONAL {\n    ?tc trt:hasTaxonName ?tn ;\n        dwc:scientificNameAuthorship ?tcauth ;\n        a dwcFP:TaxonConcept .\n    OPTIONAL { ?aug trt:augmentsTaxonConcept ?tc . }\n    OPTIONAL { ?def trt:definesTaxonConcept ?tc . }\n    OPTIONAL { ?dpr trt:deprecates ?tc . }\n    OPTIONAL { ?cite cito:cites ?tc . }\n  }\n}\nGROUP BY ?tn ?tc ?col ?rank ?genus ?species ?infrasp ?name ?authority\nLIMIT 500`;\n    // For unclear reasons, the query breaks if the limit is removed.\n\n    if (this.controller.signal?.aborted) return Promise.reject();\n\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `NameFromTN ${tnUri}`,\n    );\n\n    return this.handleName(json, justification);\n  }\n\n  /**\n   * Note this makes some assumptions on which variables are present in the bindings\n   *\n   * @internal */\n  private async handleName(\n    json: SparqlJson,\n    justification: Justification,\n  ): Promise<void> {\n    const treatmentPromises: Treatment[] = [];\n\n    const displayName: string = json.results.bindings[0].name!.value\n      .replace(\n        json.results.bindings[0].authority!.value,\n        \"\",\n      ).trim();\n\n    const colName: AuthorizedName | undefined =\n      json.results.bindings[0].col?.value\n        ? {\n          displayName,\n          authority: json.results.bindings[0].authority!.value,\n          colURI: json.results.bindings[0].col.value,\n          treatments: {\n            def: new Set(),\n            aug: new Set(),\n            dpr: new Set(),\n            cite: new Set(),\n          },\n        }\n        : undefined;\n\n    if (colName) {\n      if (this.expanded.has(colName.colURI!)) return;\n      this.expanded.add(colName.colURI!);\n    }\n\n    const authorizedNames = colName ? [colName] : [];\n\n    const taxonNameURI = json.results.bindings[0].tn?.value;\n    if (taxonNameURI) {\n      if (this.expanded.has(taxonNameURI)) return;\n      this.expanded.add(taxonNameURI); //, NameStatus.madeName);\n    }\n\n    for (const t of json.results.bindings) {\n      if (t.tc && t.tcAuth?.value) {\n        if (this.expanded.has(t.tc.value)) {\n          // console.log(\"Abbruch: already known\", t.tc.value);\n          return;\n        }\n        const def = this.makeTreatmentSet(t.defs?.value.split(\"|\"));\n        const aug = this.makeTreatmentSet(t.augs?.value.split(\"|\"));\n        const dpr = this.makeTreatmentSet(t.dprs?.value.split(\"|\"));\n        const cite = this.makeTreatmentSet(t.cites?.value.split(\"|\"));\n        if (\n          colName && t.tcAuth?.value.split(\" / \").includes(colName.authority)\n        ) {\n          colName.authority = t.tcAuth?.value;\n          colName.taxonConceptURI = t.tc.value;\n          colName.treatments = {\n            def,\n            aug,\n            dpr,\n            cite,\n          };\n        } else {\n          authorizedNames.push({\n            displayName,\n            authority: t.tcAuth.value,\n            taxonConceptURI: t.tc.value,\n            treatments: {\n              def,\n              aug,\n              dpr,\n              cite,\n            },\n          });\n        }\n        // this.expanded.set(t.tc.value, NameStatus.madeName);\n        this.expanded.add(t.tc.value);\n\n        def.forEach((t) => treatmentPromises.push(t));\n        aug.forEach((t) => treatmentPromises.push(t));\n        dpr.forEach((t) => treatmentPromises.push(t));\n      }\n    }\n\n    // TODO: handle col-data \"acceptedName\" and stuff\n\n    const treats = this.makeTreatmentSet(\n      json.results.bindings[0].tntreats?.value.split(\"|\"),\n    );\n    treats.forEach((t) => treatmentPromises.push(t));\n\n    const name: Name = {\n      displayName,\n      taxonNameURI,\n      authorizedNames,\n      justification,\n      treatments: {\n        treats,\n        cite: this.makeTreatmentSet(\n          json.results.bindings[0].tncites?.value.split(\"|\"),\n        ),\n      },\n      vernacularNames: taxonNameURI\n        ? this.getVernacular(taxonNameURI)\n        : Promise.resolve(new Map()),\n    };\n\n    let colPromises: Promise<void>[] = [];\n\n    if (colName) {\n      [colName.acceptedColURI, colPromises] = await this.getAcceptedCol(\n        colName.colURI!,\n        name,\n      );\n    }\n\n    this.pushName(name);\n\n    /** Map<synonymUri, Treatment> */\n    const newSynonyms = new Map<string, Treatment>();\n    (await Promise.all(\n      treatmentPromises.map((treat) =>\n        treat.details.then((d): [Treatment, TreatmentDetails] => {\n          return [treat, d];\n        })\n      ),\n    )).map(([treat, d]) => {\n      d.treats.aug.difference(this.expanded).forEach((s) =>\n        newSynonyms.set(s, treat)\n      );\n      d.treats.def.difference(this.expanded).forEach((s) =>\n        newSynonyms.set(s, treat)\n      );\n      d.treats.dpr.difference(this.expanded).forEach((s) =>\n        newSynonyms.set(s, treat)\n      );\n      d.treats.treattn.difference(this.expanded).forEach((s) =>\n        newSynonyms.set(s, treat)\n      );\n    });\n\n    await Promise.allSettled(\n      [\n        ...colPromises,\n        ...[...newSynonyms].map(([n, treatment]) =>\n          this.getName(n, { searchTerm: false, parent: name, treatment })\n        ),\n      ],\n    );\n  }\n\n  /** @internal */\n  private async getAcceptedCol(\n    colUri: string,\n    parent: Name,\n  ): Promise<[string, Promise<void>[]]> {\n    const query = `\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nSELECT DISTINCT ?current ?current_status (GROUP_CONCAT(DISTINCT ?dpr; separator=\"|\") AS ?dprs) WHERE {\n  BIND(<${colUri}> AS ?col)\n  {\n    ?col dwc:acceptedName ?current .\n    ?dpr dwc:acceptedName ?current .\n    ?current dwc:taxonomicStatus ?current_status .\n  } UNION {\n    ?col dwc:taxonomicStatus ?current_status .\n    OPTIONAL { ?dpr dwc:acceptedName ?col . }\n    FILTER NOT EXISTS { ?col dwc:acceptedName ?current . }\n    BIND(?col AS ?current)\n  }\n}\nGROUP BY ?current ?current_status`;\n\n    if (this.acceptedCol.has(colUri)) {\n      return [this.acceptedCol.get(colUri)!, []];\n    }\n\n    const json = await this.sparqlEndpoint.getSparqlResultSet(\n      query,\n      { signal: this.controller.signal },\n      `AcceptedCol ${colUri}`,\n    );\n\n    const promises: Promise<void>[] = [];\n\n    for (const b of json.results.bindings) {\n      for (const dpr of b.dprs!.value.split(\"|\")) {\n        if (dpr) {\n          if (!this.acceptedCol.has(b.current!.value)) {\n            this.acceptedCol.set(b.current!.value, b.current!.value);\n            promises.push(\n              this.getNameFromCol(b.current!.value, {\n                searchTerm: false,\n                parent,\n              }),\n            );\n          }\n\n          this.acceptedCol.set(dpr, b.current!.value);\n          if (!this.ignoreDeprecatedCoL) {\n            promises.push(\n              this.getNameFromCol(dpr, { searchTerm: false, parent }),\n            );\n          }\n        }\n      }\n    }\n\n    if (json.results.bindings.length === 0) {\n      // the provided colUri is not in CoL\n      // promises === []\n      if (!this.acceptedCol.has(colUri)) {\n        this.acceptedCol.set(colUri, \"INVALID COL\");\n      }\n      return [this.acceptedCol.get(colUri)!, promises];\n    }\n\n    if (!this.acceptedCol.has(colUri)) this.acceptedCol.set(colUri, colUri);\n    return [this.acceptedCol.get(colUri)!, promises];\n  }\n\n  /** @internal */\n  private async getVernacular(uri: string): Promise<vernacularNames> {\n    const result: vernacularNames = new Map();\n    const query =\n      `SELECT DISTINCT ?n WHERE { <${uri}> <http://rs.tdwg.org/dwc/terms/vernacularName> ?n . }`;\n    const bindings = (await this.sparqlEndpoint.getSparqlResultSet(query, {\n      signal: this.controller.signal,\n    }, `Vernacular ${uri}`)).results.bindings;\n    for (const b of bindings) {\n      if (b.n?.value) {\n        if (b.n[\"xml:lang\"]) {\n          if (result.has(b.n[\"xml:lang\"])) {\n            result.get(b.n[\"xml:lang\"])!.push(b.n.value);\n          } else result.set(b.n[\"xml:lang\"], [b.n.value]);\n        } else {\n          if (result.has(\"??\")) result.get(\"??\")!.push(b.n.value);\n          else result.set(\"??\", [b.n.value]);\n        }\n      }\n    }\n    return result;\n  }\n\n  /** @internal */\n  private makeTreatmentSet(urls?: string[]): Set<Treatment> {\n    if (!urls) return new Set<Treatment>();\n    return new Set<Treatment>(\n      urls.filter((url) => !!url).map((url) => {\n        if (!this.treatments.has(url)) {\n          const details = this.getTreatmentDetails(url);\n          this.treatments.set(url, {\n            url,\n            details,\n          });\n        }\n        return this.treatments.get(url) as Treatment;\n      }),\n    );\n  }\n\n  /** @internal */\n  private async getTreatmentDetails(\n    treatmentUri: string,\n  ): Promise<TreatmentDetails> {\n    const query = `\nPREFIX dc: <http://purl.org/dc/elements/1.1/>\nPREFIX dwc: <http://rs.tdwg.org/dwc/terms/>\nPREFIX dwcFP: <http://filteredpush.org/ontologies/oa/dwcFP#>\nPREFIX cito: <http://purl.org/spar/cito/>\nPREFIX trt: <http://plazi.org/vocab/treatment#>\nSELECT DISTINCT\n  ?date ?title ?mc\n  (group_concat(DISTINCT ?catalogNumber;separator=\" / \") as ?catalogNumbers)\n  (group_concat(DISTINCT ?collectionCode;separator=\" / \") as ?collectionCodes)\n  (group_concat(DISTINCT ?typeStatus;separator=\" / \") as ?typeStatuss)\n  (group_concat(DISTINCT ?countryCode;separator=\" / \") as ?countryCodes)\n  (group_concat(DISTINCT ?stateProvince;separator=\" / \") as ?stateProvinces)\n  (group_concat(DISTINCT ?municipality;separator=\" / \") as ?municipalitys)\n  (group_concat(DISTINCT ?county;separator=\" / \") as ?countys)\n  (group_concat(DISTINCT ?locality;separator=\" / \") as ?localitys)\n  (group_concat(DISTINCT ?verbatimLocality;separator=\" / \") as ?verbatimLocalitys)\n  (group_concat(DISTINCT ?recordedBy;separator=\" / \") as ?recordedBys)\n  (group_concat(DISTINCT ?eventDate;separator=\" / \") as ?eventDates)\n  (group_concat(DISTINCT ?samplingProtocol;separator=\" / \") as ?samplingProtocols)\n  (group_concat(DISTINCT ?decimalLatitude;separator=\" / \") as ?decimalLatitudes)\n  (group_concat(DISTINCT ?decimalLongitude;separator=\" / \") as ?decimalLongitudes)\n  (group_concat(DISTINCT ?verbatimElevation;separator=\" / \") as ?verbatimElevations)\n  (group_concat(DISTINCT ?gbifOccurrenceId;separator=\" / \") as ?gbifOccurrenceIds)\n  (group_concat(DISTINCT ?gbifSpecimenId;separator=\" / \") as ?gbifSpecimenIds)\n  (group_concat(DISTINCT ?creator;separator=\"; \") as ?creators)\n  (group_concat(DISTINCT ?httpUri;separator=\"|\") as ?httpUris)\n  (group_concat(DISTINCT ?aug;separator=\"|\") as ?augs)\n  (group_concat(DISTINCT ?def;separator=\"|\") as ?defs)\n  (group_concat(DISTINCT ?dpr;separator=\"|\") as ?dprs)\n  (group_concat(DISTINCT ?cite;separator=\"|\") as ?cites)\n  (group_concat(DISTINCT ?trttn;separator=\"|\") as ?trttns)\n  (group_concat(DISTINCT ?citetn;separator=\"|\") as ?citetns)\nWHERE {\n  BIND (<${treatmentUri}> as ?treatment)\n  ?treatment dc:creator ?creator .\n  OPTIONAL { ?treatment trt:publishedIn/dc:date ?date . }\n  OPTIONAL { ?treatment dc:title ?title }\n  OPTIONAL { ?treatment trt:augmentsTaxonConcept ?aug . }\n  OPTIONAL { ?treatment trt:definesTaxonConcept ?def . }\n  OPTIONAL { ?treatment trt:deprecates ?dpr . }\n  OPTIONAL { ?treatment cito:cites ?cite . ?cite a dwcFP:TaxonConcept . }\n  OPTIONAL { ?treatment trt:treatsTaxonName ?trttn . }\n  OPTIONAL { ?treatment trt:citesTaxonName ?citetn . }\n  OPTIONAL {\n    ?treatment dwc:basisOfRecord ?mc .\n    ?mc dwc:catalogNumber ?catalogNumber .\n    OPTIONAL { ?mc dwc:collectionCode ?collectionCode . }\n    OPTIONAL { ?mc dwc:typeStatus ?typeStatus . }\n    OPTIONAL { ?mc dwc:countryCode ?countryCode . }\n    OPTIONAL { ?mc dwc:stateProvince ?stateProvince . }\n    OPTIONAL { ?mc dwc:municipality ?municipality . }\n    OPTIONAL { ?mc dwc:county ?county . }\n    OPTIONAL { ?mc dwc:locality ?locality . }\n    OPTIONAL { ?mc dwc:verbatimLocality ?verbatimLocality . }\n    OPTIONAL { ?mc dwc:recordedBy ?recordedBy . }\n    OPTIONAL { ?mc dwc:eventDate ?eventDate . }\n    OPTIONAL { ?mc dwc:samplingProtocol ?samplingProtocol . }\n    OPTIONAL { ?mc dwc:decimalLatitude ?decimalLatitude . }\n    OPTIONAL { ?mc dwc:decimalLongitude ?decimalLongitude . }\n    OPTIONAL { ?mc dwc:verbatimElevation ?verbatimElevation . }\n    OPTIONAL { ?mc trt:gbifOccurrenceId ?gbifOccurrenceId . }\n    OPTIONAL { ?mc trt:gbifSpecimenId ?gbifSpecimenId . }\n    OPTIONAL { ?mc trt:httpUri ?httpUri . }\n  }\n}\nGROUP BY ?date ?title ?mc`;\n    if (this.controller.signal.aborted) {\n      return {\n        materialCitations: [],\n        figureCitations: [],\n        treats: {\n          def: new Set(),\n          aug: new Set(),\n          dpr: new Set(),\n          citetc: new Set(),\n          treattn: new Set(),\n          citetn: new Set(),\n        },\n      };\n    }\n    try {\n      const json = await this.sparqlEndpoint.getSparqlResultSet(\n        query,\n        { signal: this.controller.signal },\n        `TreatmentDetails ${treatmentUri}`,\n      );\n      const materialCitations: MaterialCitation[] = json.results.bindings\n        .filter((t) => t.mc && t.catalogNumbers?.value)\n        .map((t) => {\n          const httpUri = t.httpUris?.value?.split(\"|\");\n          return {\n            \"catalogNumber\": t.catalogNumbers!.value,\n            \"collectionCode\": t.collectionCodes?.value || undefined,\n            \"typeStatus\": t.typeStatuss?.value || undefined,\n            \"countryCode\": t.countryCodes?.value || undefined,\n            \"stateProvince\": t.stateProvinces?.value || undefined,\n            \"municipality\": t.municipalitys?.value || undefined,\n            \"county\": t.countys?.value || undefined,\n            \"locality\": t.localitys?.value || undefined,\n            \"verbatimLocality\": t.verbatimLocalitys?.value || undefined,\n            \"recordedBy\": t.recordedBys?.value || undefined,\n            \"eventDate\": t.eventDates?.value || undefined,\n            \"samplingProtocol\": t.samplingProtocols?.value || undefined,\n            \"decimalLatitude\": t.decimalLatitudes?.value || undefined,\n            \"decimalLongitude\": t.decimalLongitudes?.value || undefined,\n            \"verbatimElevation\": t.verbatimElevations?.value || undefined,\n            \"gbifOccurrenceId\": t.gbifOccurrenceIds?.value || undefined,\n            \"gbifSpecimenId\": t.gbifSpecimenIds?.value || undefined,\n            httpUri: httpUri?.length ? httpUri : undefined,\n          };\n        });\n      const figureQuery = `\nPREFIX cito: <http://purl.org/spar/cito/>\nPREFIX fabio: <http://purl.org/spar/fabio/>\nPREFIX dc: <http://purl.org/dc/elements/1.1/>\nSELECT DISTINCT ?url ?description WHERE {\n  <${treatmentUri}> cito:cites ?cites .\n  ?cites a fabio:Figure ;\n  fabio:hasRepresentation ?url .\n  OPTIONAL { ?cites dc:description ?description . }\n} `;\n      const figures = (await this.sparqlEndpoint.getSparqlResultSet(\n        figureQuery,\n        { signal: this.controller.signal },\n        `TreatmentDetails/Figures ${treatmentUri}`,\n      )).results.bindings;\n      const figureCitations = figures.filter((f) => f.url?.value).map(\n        (f) => {\n          return { url: f.url!.value, description: f.description?.value };\n        },\n      );\n      return {\n        creators: json.results.bindings[0]?.creators?.value,\n        date: json.results.bindings[0]?.date?.value\n          ? parseInt(json.results.bindings[0].date.value, 10)\n          : undefined,\n        title: json.results.bindings[0]?.title?.value,\n        materialCitations,\n        figureCitations,\n        treats: {\n          def: new Set(\n            json.results.bindings[0]?.defs?.value\n              ? json.results.bindings[0].defs.value.split(\"|\")\n              : undefined,\n          ),\n          aug: new Set(\n            json.results.bindings[0]?.augs?.value\n              ? json.results.bindings[0].augs.value.split(\"|\")\n              : undefined,\n          ),\n          dpr: new Set(\n            json.results.bindings[0]?.dprs?.value\n              ? json.results.bindings[0].dprs.value.split(\"|\")\n              : undefined,\n          ),\n          citetc: new Set(\n            json.results.bindings[0]?.cites?.value\n              ? json.results.bindings[0].cites.value.split(\"|\")\n              : undefined,\n          ),\n          treattn: new Set(\n            json.results.bindings[0]?.trttns?.value\n              ? json.results.bindings[0].trttns.value.split(\"|\")\n              : undefined,\n          ),\n          citetn: new Set(\n            json.results.bindings[0]?.citetns?.value\n              ? json.results.bindings[0].citetns.value.split(\"|\")\n              : undefined,\n          ),\n        },\n      };\n    } catch (error) {\n      console.warn(\"SPARQL Error: \" + error);\n      return {\n        materialCitations: [],\n        figureCitations: [],\n        treats: {\n          def: new Set(),\n          aug: new Set(),\n          dpr: new Set(),\n          citetc: new Set(),\n          treattn: new Set(),\n          citetn: new Set(),\n        },\n      };\n    }\n  }\n\n  /** Allows iterating over the synonyms while they are found */\n  [Symbol.asyncIterator](): AsyncIterator<Name> {\n    let returnedSoFar = 0;\n    return {\n      next: () =>\n        new Promise<IteratorResult<Name>>(\n          (resolve, reject) => {\n            const callback = () => {\n              if (this.controller.signal.aborted) {\n                reject(new Error(\"SynyonymGroup has been aborted\"));\n              } else if (returnedSoFar < this.names.length) {\n                resolve({ value: this.names[returnedSoFar++] });\n              } else if (this.isFinished) {\n                resolve({ done: true, value: true });\n              } else {\n                const listener = () => {\n                  this.monitor.removeEventListener(\"updated\", listener);\n                  callback();\n                };\n                this.monitor.addEventListener(\"updated\", listener);\n              }\n            };\n            callback();\n          },\n        ),\n    };\n  }\n}\n\n/** The central object.\n *\n * Each `Name` exists because of a taxon-name, taxon-concept or col-taxon in the data.\n * Each `Name` is uniquely determined by its human-readable latin name (for taxa ranking below genus, this is a multi-part name \u2014 binomial or trinomial) and kingdom.\n */\nexport type Name = {\n  /** taxonomic kingdom */\n  // kingdom: string;\n  /** Human-readable name */\n  displayName: string;\n\n  /** vernacular names */\n  vernacularNames: Promise<vernacularNames>;\n\n  // /** Contains the family tree / upper taxons accorindg to CoL / treatmentbank.\n  //  * //TODO */\n  // trees: Promise<{\n  //   col?: Tree;\n  //   tb?: Tree;\n  // }>;\n\n  /** The URI of the respective `dwcFP:TaxonName` if it exists */\n  taxonNameURI?: string;\n  /** All `AuthorizedName`s with this name */\n  authorizedNames: AuthorizedName[];\n\n  /** How this name was found */\n  justification: Justification;\n\n  /** treatments directly associated with .taxonNameUri */\n  treatments: {\n    treats: Set<Treatment>;\n    cite: Set<Treatment>;\n  };\n};\n\n/**\n * A map from language tags (IETF) to an array of vernacular names.\n */\nexport type vernacularNames = Map<string, string[]>;\n\n/** Why a given Name was found (ther migth be other possible justifications) */\nexport type Justification = {\n  searchTerm: true;\n  /** indicates that this is a subTaxon of the parent */\n  subTaxon: boolean;\n} | {\n  searchTerm: false;\n  parent: Name;\n  /** if missing, indicates synonymy according to CoL or subTaxon */\n  treatment?: Treatment;\n};\n\n/**\n * Corresponds to a taxon-concept or a CoL-Taxon\n */\nexport type AuthorizedName = {\n  // TODO: neccesary?\n  /** this may not be neccesary, as `AuthorizedName`s should only appear within a `Name` */\n  // name: Name;\n  /** Human-readable name */\n  displayName: string;\n  /** Human-readable authority */\n  authority: string;\n\n  /** The URI of the respective `dwcFP:TaxonConcept` if it exists */\n  taxonConceptURI?: string;\n\n  /** The URI of the respective CoL-taxon if it exists */\n  colURI?: string;\n  /** The URI of the corresponding accepted CoL-taxon if it exists.\n   *\n   * Always present if colURI is present, they are the same if it is the accepted CoL-Taxon.\n   *\n   * May be the string \"INVALID COL\" if the colURI is not valid.\n   */\n  acceptedColURI?: string;\n\n  // TODO: sensible?\n  // /** these are CoL-taxa linked in the rdf, which differ lexically */\n  // seeAlsoCol: string[];\n\n  /** treatments directly associated with .taxonConceptURI */\n  treatments: {\n    def: Set<Treatment>;\n    aug: Set<Treatment>;\n    dpr: Set<Treatment>;\n    cite: Set<Treatment>;\n  };\n};\n\n/** A plazi-treatment */\nexport type Treatment = {\n  url: string;\n\n  /** Details are behind a promise becuase they are loaded with a separate query. */\n  details: Promise<TreatmentDetails>;\n};\n\n/** Details of a treatment */\nexport type TreatmentDetails = {\n  materialCitations: MaterialCitation[];\n  figureCitations: FigureCitation[];\n  date?: number;\n  creators?: string;\n  title?: string;\n  treats: {\n    def: Set<string>;\n    aug: Set<string>;\n    dpr: Set<string>;\n    citetc: Set<string>;\n    treattn: Set<string>;\n    citetn: Set<string>;\n  };\n};\n\n/** A cited material */\nexport type MaterialCitation = {\n  \"catalogNumber\": string;\n  \"collectionCode\"?: string;\n  \"typeStatus\"?: string;\n  \"countryCode\"?: string;\n  \"stateProvince\"?: string;\n  \"municipality\"?: string;\n  \"county\"?: string;\n  \"locality\"?: string;\n  \"verbatimLocality\"?: string;\n  \"recordedBy\"?: string;\n  \"eventDate\"?: string;\n  \"samplingProtocol\"?: string;\n  \"decimalLatitude\"?: string;\n  \"decimalLongitude\"?: string;\n  \"verbatimElevation\"?: string;\n  \"gbifOccurrenceId\"?: string;\n  \"gbifSpecimenId\"?: string;\n  \"httpUri\"?: string[];\n};\n\n/** A cited figure */\nexport type FigureCitation = {\n  url: string;\n  description?: string;\n};\n"],
  "mappings": "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",
  "names": ["t"]
}
